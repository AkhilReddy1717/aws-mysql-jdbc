diff --git a/README.md b/README.md
index 2527c6d..6db225b 100644
--- a/README.md
+++ b/README.md
@@ -93,18 +93,17 @@ For more information about parameters that can be configured with the AWS JDBC D
 
 In addition to [the parameters that can be configured for the MySQL Connector/J driver](https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference-configuration-properties.html), the following parameters can also be passed to the AWS JDBC Driver through the connection URL to configure additional driver behavior.
 
-| Parameter       | Value           | Required      | Description  |
-| ------------- |:-------------:|:-------------:| ----- |
-|`enableClusterAwareFailover` | Boolean | No | Set to true to enable the fast failover behavior offerred by the AWS JDBC Driver. Set to false for simple JDBC connections that do not require fast failover functionality.<br/><br/>**Default value:** `true` |
-|`clusterInstanceHostPattern` | String | If connecting using an IP address or custom domain URL: Yes<br/>Otherwise: No | This parameter is not required unless connecting to an AWS RDS cluster via an IP address or custom domain URL. In those cases, this parameter specifies the cluster instance DNS pattern that will be used to build a complete instance endpoint. A "?" character in this pattern should be used as a placeholder for cluster instance identifiers. <br/><br/>Example: `?.my-domain.com`, `any-subdomain.?.my-domain.com:9999`<br/><br/>Usecase Example: If your cluster instance endpoints followed this pattern:`instanceIdentifier1.customHost`, `instanceIdentifier2.customHost`, etc. and you wanted your initial connection to be to `customHost:1234`, then your connection string should look something like this: `jdbc:postgresql:aws://customHost:1234/test?clusterInstanceHostPattern=?.customHost`<br/><br/>**Default value:** if unspecified, and the provided connection string is not an IP address or custom domain, the driver will automatically acquire the cluster instance host pattern from the customer-provided connection string. |
-|`clusterId` | String | No | A unique identifier for the cluster. Connections with the same cluster id share a cluster topology cache. This connection parameter is not required and thus should only be set if desired. <br/><br/>**Default value:** If unspecified, the driver will automatically acquire a cluster id for AWS RDS clusters. |
-|`clusterTopologyRefreshRateMs` | Integer | No | Cluster topology refresh rate in milliseconds. The cached topology for the cluster will be invalidated after the specified time, after which it will be updated during the next interaction with the connection.<br/><br/>**Default value:** `30000` |
-|`failoverTimeoutMs` | Integer | No | Maximum allowed time in millipseconds to attempt reconnecting to a new writer or reader instance after a cluster failover is initiated.<br/><br/>**Default value:** `60000` |
-|`failoverClusterTopologyRefreshRateMs` | Integer | No | Cluster topology refresh rate in milliseconds during a writer failover process. During the writer failover process, cluster topology may be refreshed at a faster pace than normal to speed up discovery of the newly promoted writer.<br/><br/>**Default value:** `5000` |
-|`failoverWriterReconnectIntervalMs` | Integer | No | Interval of time in milliseconds to wait between attempts to reconnect to a failed writer during a writer failover process.<br/><br/>**Default value:** `5000` |
-|`failoverReaderConnectTimeoutMs` | Integer | No | Maximum allowed time in milliseconds to attempt to connect to a reader instance during a reader failover process. <br/><br/>**Default value:** `5000`
-|`acceptAwsProtocolOnly` | Boolean | If using simultaneously with another postgresql driver that supports the same protocols: Yes<br/>Otherwise: No | Set to true to only accept connections for URLs with the jdbc:postgresql:aws:// protocol. This setting should be set to true when running an application that uses this driver simultaneously with another postgresql driver that supports the same protocols (eg the PostgreSQL JDBC Driver), to ensure the driver protocols do not clash. This behavior can also be set at the driver level for every connection via the Driver.setAcceptAwsProtocolOnly method; however, this connection parameter will take priority when present.<br/><br/>**Default value:** `false`
-|`gatherPerfMetrics` | Boolean | No | Set to true if you would like the driver to record failover-associated metrics, which will then be logged upon closing the connection. This behavior can also be set at the driver level for every connection via the Driver.setAcceptAwsProtocolOnly method; however, this connection parameter will take priority when present.<br/><br/>**Default value:** `false` | 
+| Parameter       | Value           | Description  |
+| ------------- |:-------------:| ----- |
+|`enableClusterAwareFailover` | Boolean | Set to true to enable the fast failover behavior offerred by the AWS JDBC Driver. Set to false for simple JDBC connections that do not require fast failover functionality.<br/><br/>**Default value:** `true` |
+|`clusterInstanceHostPattern` | String | The cluster instance DNS pattern that will be used to build a complete instance endpoint. A "?" character in this pattern should be used as a placeholder for cluster instance names. This pattern is required to be specified for IP address or custom domain connections to AWS RDS clusters. <br/><br/>Example: `?.my-domain.com`, `any-subdomain.?.my-domain.com:9999`<br/><br/>Usecase Example: If your instances endpoint came in the following pattern:`instance1.customHost`, `instance2.customHost`, etc. Then following connection string would look something like this: `jdbc:mysql:aws://customHost:1234/test?clusterInstanceHostPattern=?.customHost`<br/><br/>**Default value:** if unspecified, and the provided connection string is not an IP address or custom domain, the driver will automatically acquire the cluster instance host pattern from the customer-provided connection string. |
+|`clusterId` | String | A unique identifier for the cluster. Connections with the same cluster id share a cluster topology cache.<br/><br/>**Default value:** If unspecified, the driver will automatically acquire cluster Id for AWS RDS clusters. |
+|`clusterTopologyRefreshRateMs` | Integer | Cluster topology refresh rate in milliseconds. The cached topology for the cluster will be invalidated after the specified time, after which it will be updated during the next interaction with the connection.<br/><br/>**Default value:** `30000` |
+|`failoverTimeoutMs` | Integer | Maximum allowed time in milliseconds to attempt reconnecting to a new writer or reader instance after a cluster failover is initiated.<br/><br/>**Default value:** `60000` |
+|`failoverClusterTopologyRefreshRateMs` | Integer | Cluster topology refresh rate in milliseconds during a writer failover process. During the writer failover process, cluster topology may be refreshed at a faster pace than normal to speed up discovery of the newly promoted writer.<br/><br/>**Default value:** `5000` |
+|`failoverWriterReconnectIntervalMs` | Integer | Interval of time in milliseconds to wait between attempts to reconnect to a failed writer during a writer failover process.<br/><br/>**Default value:** `5000` |
+|`failoverReaderConnectTimeoutMs` | Integer | Maximum allowed time in milliseconds to attempt to connect to a reader instance during a reader failover process. <br/><br/>**Default value:** `5000`
+|`acceptAwsProtocolOnly` | Boolean | Set to true to only accept connections for URLs with the jdbc:mysql:aws:// protocol. This setting should be set to true when running an application that uses this driver simultaneously with another mysql driver that supports the same protocols (eg the mysql-connector-j driver), to ensure the driver protocols do not clash.<br/><br/>**Default value:** `false`
 #### Failover Exception Codes
 ##### 08001 - Unable to Establish SQL Connection
 When the driver throws a SQLException with code ```08001```, it means the original connection failed, and the driver tried to failover to a new instance, but was unable to. There are various reasons this may happen: no nodes were available, a network failure occurred, etc. In this scenario, please wait until the server is up or other problems are solved. (Exception will be thrown.)
diff --git a/build.gradle.kts b/build.gradle.kts
index 09162d3..2b30a7a 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -104,7 +104,6 @@ tasks.shadowJar {
     from("${project.rootDir}") {
         include("README")
         include("LICENSE")
-        include("THIRD-PARTY-LICENSES")
         into("META-INF/")
     }
 
diff --git a/showMeDif! b/showMeDif!
deleted file mode 100644
index bc95cf7..0000000
--- a/showMeDif!
+++ /dev/null
@@ -1,62 +0,0 @@
-diff --git a/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/AuroraTopologyService.java b/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/AuroraTopologyService.java
-index d77655b..3b66dbc 100644
---- a/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/AuroraTopologyService.java
-+++ b/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/AuroraTopologyService.java
-@@ -285,7 +285,7 @@ public class AuroraTopologyService implements TopologyService, CanCollectPerform
-   }
- 
-   private Map<String, String> getPropertiesFromTopology(ResultSet resultSet) throws SQLException {
--    Map<String, String> properties = new HashMap<>(this.clusterInstanceTemplate.getHostProperties());
-+    Map<String, String> properties = new HashMap<>();
-     properties.put(TopologyServicePropertyKeys.INSTANCE_NAME, resultSet.getString(FIELD_SERVER_ID));
-     properties.put(TopologyServicePropertyKeys.SESSION_ID, resultSet.getString(FIELD_SESSION_ID));
-     properties.put(
-diff --git a/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareConnectionProxy.java b/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareConnectionProxy.java
-index 84b88aa..adc9445 100644
---- a/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareConnectionProxy.java
-+++ b/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareConnectionProxy.java
-@@ -467,7 +467,7 @@ public class ClusterAwareConnectionProxy extends MultiHostConnectionProxy
-   }
- 
-   private HostInfo createClusterInstanceTemplate(HostInfo mainHost, String host, int port) {
--    Map<String, String> properties = new HashMap<>(this.initialConnectionProps);
-+    Map<String, String> properties = new HashMap<>(mainHost.getHostProperties());
-     properties.put(PropertyKey.connectTimeout.getKeyName(), String.valueOf(this.failoverConnectTimeoutMs));
-     properties.put(PropertyKey.socketTimeout.getKeyName(), String.valueOf(this.failoverSocketTimeoutMs));
- 
-diff --git a/src/test/java/testsuite/regression/ConnectionRegressionTest.java b/src/test/java/testsuite/regression/ConnectionRegressionTest.java
-index 1431965..66afc74 100644
---- a/src/test/java/testsuite/regression/ConnectionRegressionTest.java
-+++ b/src/test/java/testsuite/regression/ConnectionRegressionTest.java
-@@ -57,7 +57,10 @@ import com.mysql.cj.util.LogUtils;
- import com.mysql.cj.util.StringUtils;
- import com.mysql.cj.util.TimeUtil;
- import com.mysql.cj.util.Util;
--import org.junit.jupiter.api.*;
-+import org.junit.jupiter.api.Disabled;
-+import org.junit.jupiter.api.MethodOrderer;
-+import org.junit.jupiter.api.Test;
-+import org.junit.jupiter.api.TestMethodOrder;
- import testsuite.BaseQueryInterceptor;
- import testsuite.BaseTestCase;
- import testsuite.BufferingLogger;
-@@ -5867,7 +5870,6 @@ public class ConnectionRegressionTest extends BaseTestCase {
-      * 
-      * @throws Exception
-      */
--    @Disabled
-     @Test
-     public void testBug69579() throws Exception {
-         // Mock Server that accepts network connections and does nothing with them, for connection timeout testing.
-@@ -5924,9 +5926,10 @@ public class ConnectionRegressionTest extends BaseTestCase {
-         final String testURL = "jdbc:mysql://localhost:" + serverPort;
-         Connection testConn = null;
-         final int oldLoginTimeout = DriverManager.getLoginTimeout();
--        final int loginTimeout = 6;
-+        final int loginTimeout = 3;
-         final int testTimeout = loginTimeout * 2;
-         long timestamp = System.currentTimeMillis();
-+
-         try {
-             DriverManager.setLoginTimeout(loginTimeout);
- 
diff --git a/src/main/resources/com/mysql/cj/LocalizedErrorMessages.properties b/src/main/resources/com/mysql/cj/LocalizedErrorMessages.properties
index c64b104..39bd763 100644
--- a/src/main/resources/com/mysql/cj/LocalizedErrorMessages.properties
+++ b/src/main/resources/com/mysql/cj/LocalizedErrorMessages.properties
@@ -997,45 +997,42 @@ ConnectionProperties.failoverWriterReconnectIntervalMs=Interval of time to wait
 ConnectionProperties.failoverReaderConnectTimeoutMs=Reader connection attempt timeout during a reader failover process. 
 ConnectionProperties.acceptAwsProtocolOnly=Set to true to only accept connections for URLs with the jdbc:mysql:aws:// protocol. This setting should be set to true when running an application that uses this driver simultaneously with another mysql driver that supports the same protocols (eg the mysql-connector-j driver), to ensure the driver protocols do not clash.
 
-AuroraTopologyService.1=[AuroraTopologyService] clusterId=''{0}''
-AuroraTopologyService.2=[AuroraTopologyService] clusterInstance host=''{0}'', port={1,number,#}, database=''{2}''
-
 ClusterAwareConnectionProxy.1=Transaction resolution unknown. Please re-configure session state if required and try restarting transaction.
 ClusterAwareConnectionProxy.2=Unable to establish SQL connection to writer node.
 ClusterAwareConnectionProxy.3=The active SQL connection has changed due to a connection failure. Please re-configure session state if required.
 ClusterAwareConnectionProxy.4=Unable to establish SQL connection to reader node.
 ClusterAwareConnectionProxy.5=Invalid value in ''clusterInstanceHostPattern'' configuration property.
-ClusterAwareConnectionProxy.6=The 'clusterInstanceHostPattern' configuration property is required when an IP address or custom domain is used to connect to the cluster.
-ClusterAwareConnectionProxy.7=RDS Proxy endpoint can't be used as an instance pattern.
-ClusterAwareConnectionProxy.8=[ClusterAwareConnectionProxy] Cluster-aware failover is enabled.
-ClusterAwareConnectionProxy.9=[ClusterAwareConnectionProxy] ''{0}'' configuration setting: {1}
-ClusterAwareConnectionProxy.10=[ClusterAwareConnectionProxy] {0}={1}
-ClusterAwareConnectionProxy.11=[ClusterAwareConnectionProxy] Topology obtained: {0}
-ClusterAwareConnectionProxy.12=[ClusterAwareConnectionProxy] Detected an exception while executing a command.
-ClusterAwareConnectionProxy.13=[ClusterAwareConnectionProxy] Cluster-aware failover is disabled.
-ClusterAwareConnectionProxy.14=[ClusterAwareConnectionProxy] Connection is closed by user.
-ClusterAwareConnectionProxy.15=[ClusterAwareConnectionProxy] Connected to: {0}
-ClusterAwareConnectionProxy.16=[ClusterAwareConnectionProxy] Starting writer failover procedure.
-ClusterAwareConnectionProxy.17=[ClusterAwareConnectionProxy] Starting reader failover procedure.
-ClusterAwareConnectionProxy.18=RDS Custom Cluster endpoint can't be used as an instance pattern.
-ClusterAwareConnectionProxy.19=The active SQL connection has changed. Please re-configure session state if required.
-ClusterAwareConnectionProxy.20=The provided connection string does not appear to match an expected Aurora DNS pattern. Please set the 'clusterInstanceHostPattern' configuration property to specify the host pattern for the cluster you are trying to connect to.
+ClusterAwareConnectionProxy.6=''clusterInstanceHostPattern'' configuration property is required when IP address is used to connect to cluster.
+ClusterAwareConnectionProxy.7=The provided connection string appears to be a custom domain. The driver requires the ''clusterInstanceHostPattern'' configuration property to be set for custom domains.
+ClusterAwareConnectionProxy.8=RDS Proxy endpoint can't be used as an instance pattern.
+ClusterAwareConnectionProxy.9=[ClusterAwareConnectionProxy] Cluster-aware failover is enabled.
+ClusterAwareConnectionProxy.10=[ClusterAwareConnectionProxy] ''{0}'' configuration setting: {1}
+ClusterAwareConnectionProxy.11=[ClusterAwareConnectionProxy] clusterInstance host=''{0}'', port={1,number,#}
+ClusterAwareConnectionProxy.12=[ClusterAwareConnectionProxy] {0}={1}
+ClusterAwareConnectionProxy.13=[ClusterAwareConnectionProxy] {0}=''{1}''
+ClusterAwareConnectionProxy.16=[ClusterAwareConnectionProxy] Topology obtained: {0}
+ClusterAwareConnectionProxy.17=[ClusterAwareConnectionProxy] Detected an exception while executing a command.
+ClusterAwareConnectionProxy.18=[ClusterAwareConnectionProxy] Cluster-aware failover is disabled.
+ClusterAwareConnectionProxy.19=[ClusterAwareConnectionProxy] Connection is closed by user.
+ClusterAwareConnectionProxy.20=[ClusterAwareConnectionProxy] Connected to: {0}
+ClusterAwareConnectionProxy.21=[ClusterAwareConnectionProxy] Starting writer failover procedure.
+ClusterAwareConnectionProxy.23=[ClusterAwareConnectionProxy] Starting reader failover procedure.
+ClusterAwareConnectionProxy.24=RDS Custom Cluster endpoint can't be used as an instance pattern.
+ClusterAwareConnectionProxy.25=The active SQL connection has changed. Please re-configure session state if required.
 
 ClusterAwareWriterFailoverHandler.1=Thread was interrupted.
-ClusterAwareWriterFailoverHandler.2=[ClusterAwareWriterFailoverHandler] Successfully re-connected to the current writer instance: ''{0}''
-ClusterAwareWriterFailoverHandler.3=[ClusterAwareWriterFailoverHandler] Failed to connect to the writer instance.
-ClusterAwareWriterFailoverHandler.4=[ClusterAwareWriterFailoverHandler] Successfully connected to the new writer instance: ''{0}''
-ClusterAwareWriterFailoverHandler.5=[ClusterAwareWriterFailoverHandler] {0} successfully established a connection but doesn't contain a valid topology
-ClusterAwareWriterFailoverHandler.6=[ClusterAwareWriterFailoverHandler] [TaskA] Attempting to re-connect to the current writer instance: ''{0}''
-ClusterAwareWriterFailoverHandler.7=[ClusterAwareWriterFailoverHandler] Failover was called with a null topology
-ClusterAwareWriterFailoverHandler.8=[ClusterAwareWriterFailoverHandler] [TaskA] Finished
-ClusterAwareWriterFailoverHandler.9=[ClusterAwareWriterFailoverHandler] [TaskB] Attempting to connect to a new writer instance
-ClusterAwareWriterFailoverHandler.10=[ClusterAwareWriterFailoverHandler] [TaskB] Finished
-ClusterAwareWriterFailoverHandler.11=[ClusterAwareWriterFailoverHandler] [TaskB] Connected to reader [{0,number,#}] ''{1}''
-ClusterAwareWriterFailoverHandler.12=[ClusterAwareWriterFailoverHandler] [TaskB] Failed to connect to any reader.
-ClusterAwareWriterFailoverHandler.13=[ClusterAwareWriterFailoverHandler] [TaskB] Topology obtained: {0}
-ClusterAwareWriterFailoverHandler.14=[ClusterAwareWriterFailoverHandler] [TaskB] Trying to connect to a new writer ''{0}''
-ClusterAwareWriterFailoverHandler.15=[ClusterAwareWriterFailoverHandler] [TaskB] encountered an exception: {0}
+ClusterAwareWriterFailoverHandler.2=[ClusterAwareWriterFailoverHandler] Successfully re-connected to the current writer ''{0}''
+ClusterAwareWriterFailoverHandler.3=[ClusterAwareWriterFailoverHandler] Failed to connect to writer.
+ClusterAwareWriterFailoverHandler.4=[ClusterAwareWriterFailoverHandler] Successfully connected to a new writer ''{0}''
+ClusterAwareWriterFailoverHandler.5=[ClusterAwareWriterFailoverHandler] [TaskA] Trying to connect to the current writer ''{0}''
+ClusterAwareWriterFailoverHandler.6=[ClusterAwareWriterFailoverHandler] [TaskA] Started
+ClusterAwareWriterFailoverHandler.7=[ClusterAwareWriterFailoverHandler] [TaskA] Finished
+ClusterAwareWriterFailoverHandler.8=[ClusterAwareWriterFailoverHandler] [TaskB] Started
+ClusterAwareWriterFailoverHandler.9=[ClusterAwareWriterFailoverHandler] [TaskB] Finished
+ClusterAwareWriterFailoverHandler.10=[ClusterAwareWriterFailoverHandler] [TaskB] Connected to reader [{0,number,#}] ''{1}''
+ClusterAwareWriterFailoverHandler.11=[ClusterAwareWriterFailoverHandler] [TaskB] Failed to connect to any reader.
+ClusterAwareWriterFailoverHandler.12=[ClusterAwareWriterFailoverHandler] [TaskB] Topology obtained: {0}
+ClusterAwareWriterFailoverHandler.13=[ClusterAwareWriterFailoverHandler] [TaskB] Trying to connect to a new writer ''{0}''
 
 ClusterAwareReaderFailoverHandler.1=Thread was interrupted.
 ClusterAwareReaderFailoverHandler.2=[ClusterAwareReaderFailoverHandler] Connected to reader [{0,number,#}]
diff --git a/src/main/user-impl/java/com/mysql/cj/jdbc/NonRegisteringDriver.java b/src/main/user-impl/java/com/mysql/cj/jdbc/NonRegisteringDriver.java
index dfed492..4a05ec0 100644
--- a/src/main/user-impl/java/com/mysql/cj/jdbc/NonRegisteringDriver.java
+++ b/src/main/user-impl/java/com/mysql/cj/jdbc/NonRegisteringDriver.java
@@ -75,8 +75,6 @@ import com.mysql.cj.util.StringUtils;
  */
 public class NonRegisteringDriver implements java.sql.Driver {
 
-    protected static boolean acceptAwsProtocolOnly = false;
-
     /*
      * Standardizes OS name information to align with other drivers/clients
      * for MySQL connection attributes
@@ -147,25 +145,10 @@ public class NonRegisteringDriver implements java.sql.Driver {
      *                if a database access error occurs or the url is null
      */
     @Override
-    public boolean acceptsURL(String url) {
-        if (isAcceptAwsProtocolOnly(url) && !url.startsWith(Type.SINGLE_CONNECTION_AWS.getScheme())) {
-            return false;
-        }
+    public boolean acceptsURL(String url) throws SQLException {
         return (ConnectionUrl.acceptsUrl(url));
     }
 
-    private boolean isAcceptAwsProtocolOnly(String url) {
-        Properties info = new Properties();
-        ConnectionUrl conStr = ConnectionUrl.getConnectionUrlInstance(url, info);
-        Map<String, String> connProps = conStr.getOriginalProperties();
-
-        if (connProps.containsKey("acceptAwsProtocolOnly")) {
-            return Boolean.parseBoolean(connProps.get("acceptAwsProtocolOnly"));
-        } else {
-            return acceptAwsProtocolOnly;
-        }
-    }
-
     //
     // return the database name property
     //
@@ -212,25 +195,26 @@ public class NonRegisteringDriver implements java.sql.Driver {
             }
 
             ConnectionUrl conStr = ConnectionUrl.getConnectionUrlInstance(url, info);
-
+            Map<String, String> connProps = conStr.getOriginalProperties();
+            boolean acceptAwsProtocolOnly = Boolean.parseBoolean(connProps.getOrDefault(PropertyKey.acceptAwsProtocolOnly.getKeyName(), "false"));
             switch (conStr.getType()) {
                 case SINGLE_CONNECTION:
-                    return isAcceptAwsProtocolOnly(url) ? null : com.mysql.cj.jdbc.ConnectionImpl.getInstance(conStr.getMainHost());
+                    return acceptAwsProtocolOnly ? null : com.mysql.cj.jdbc.ConnectionImpl.getInstance(conStr.getMainHost());
 
                 case SINGLE_CONNECTION_AWS:
                     return ClusterAwareConnectionProxy.autodetectClusterAndCreateProxyInstance(conStr);
 
                 case FAILOVER_CONNECTION:
                 case FAILOVER_DNS_SRV_CONNECTION:
-                    return isAcceptAwsProtocolOnly(url) ? null : FailoverConnectionProxy.createProxyInstance(conStr);
+                    return acceptAwsProtocolOnly ? null : FailoverConnectionProxy.createProxyInstance(conStr);
 
                 case LOADBALANCE_CONNECTION:
                 case LOADBALANCE_DNS_SRV_CONNECTION:
-                    return isAcceptAwsProtocolOnly(url) ? null : LoadBalancedConnectionProxy.createProxyInstance(conStr);
+                    return acceptAwsProtocolOnly ? null : LoadBalancedConnectionProxy.createProxyInstance(conStr);
 
                 case REPLICATION_CONNECTION:
                 case REPLICATION_DNS_SRV_CONNECTION:
-                    return isAcceptAwsProtocolOnly(url) ? null : ReplicationConnectionProxy.createProxyInstance(conStr);
+                    return acceptAwsProtocolOnly ? null : ReplicationConnectionProxy.createProxyInstance(conStr);
 
                 default:
                     return null;
diff --git a/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/AuroraTopologyService.java b/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/AuroraTopologyService.java
index 3b66dbc..4b6a90a 100644
--- a/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/AuroraTopologyService.java
+++ b/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/AuroraTopologyService.java
@@ -30,12 +30,10 @@
 
 package com.mysql.cj.jdbc.ha.ca;
 
-import com.mysql.cj.Messages;
 import com.mysql.cj.conf.ConnectionUrl;
 import com.mysql.cj.conf.HostInfo;
 import com.mysql.cj.jdbc.JdbcConnection;
 import com.mysql.cj.log.Log;
-import com.mysql.cj.log.NullLogger;
 import com.mysql.cj.util.ExpiringCache;
 
 import java.sql.ResultSet;
@@ -79,26 +77,22 @@ public class AuroraTopologyService implements TopologyService, CanCollectPerform
   static final String FIELD_LAST_UPDATED = "LAST_UPDATE_TIMESTAMP";
   static final String FIELD_REPLICA_LAG = "REPLICA_LAG_IN_MILLISECONDS";
 
+  protected static final int NO_CONNECTION_INDEX = -1;
+
   protected static final ExpiringCache<String, ClusterTopologyInfo> topologyCache =
       new ExpiringCache<>(DEFAULT_CACHE_EXPIRE_MS);
   private static final Object cacheLock = new Object();
 
   protected String clusterId;
-  protected HostInfo clusterInstanceTemplate;
+  protected HostInfo clusterInstanceHost;
 
   protected ClusterAwareTimeMetricsHolder queryTopologyMetrics =
       new ClusterAwareTimeMetricsHolder("Topology Query");
   protected boolean gatherPerfMetrics = false;
 
-  /** Null logger shared by all connections at startup. */
-  protected static final Log NULL_LOGGER = new NullLogger(Log.LOGGER_INSTANCE_NAME);
-
-  /** The logger we're going to use. */
-  protected transient Log log = NULL_LOGGER;
-
   /** Initializes a service with topology default refresh rate. */
-  public AuroraTopologyService(Log log) {
-    this(DEFAULT_REFRESH_RATE_IN_MILLISECONDS, log);
+  public AuroraTopologyService() {
+    this(DEFAULT_REFRESH_RATE_IN_MILLISECONDS);
   }
 
   /**
@@ -106,14 +100,10 @@ public class AuroraTopologyService implements TopologyService, CanCollectPerform
    *
    * @param refreshRateInMilliseconds Topology refresh rate in millis
    */
-  public AuroraTopologyService(int refreshRateInMilliseconds, Log log) {
+  public AuroraTopologyService(int refreshRateInMilliseconds) {
     this.refreshRateInMilliseconds = refreshRateInMilliseconds;
     this.clusterId = UUID.randomUUID().toString();
-    this.clusterInstanceTemplate = new HostInfo(null, "?", HostInfo.NO_PORT, null, null);
-
-    if (log != null) {
-      this.log = log;
-    }
+    this.clusterInstanceHost = new HostInfo(null, "?", HostInfo.NO_PORT, null, null);
   }
 
   /**
@@ -134,7 +124,6 @@ public class AuroraTopologyService implements TopologyService, CanCollectPerform
    */
   @Override
   public void setClusterId(String clusterId) {
-    this.log.logTrace(Messages.getString("AuroraTopologyService.1", new Object[]{clusterId}));
     this.clusterId = clusterId;
   }
 
@@ -145,13 +134,11 @@ public class AuroraTopologyService implements TopologyService, CanCollectPerform
    *
    * <p>Examples: "?.mydomain.com", "db-instance.?.mydomain.com"
    *
-   * @param clusterInstanceTemplate Cluster instance details including host dns pattern.
+   * @param clusterInstanceHost Cluster instance details including host dns pattern.
    */
   @Override
-  public void setClusterInstanceTemplate(HostInfo clusterInstanceTemplate) {
-    this.log.logTrace(Messages.getString("AuroraTopologyService.2",
-            new Object[]{clusterInstanceTemplate.getHost(), clusterInstanceTemplate.getPort(), clusterInstanceTemplate.getDatabase()}));
-    this.clusterInstanceTemplate = clusterInstanceTemplate;
+  public void setClusterInstanceHost(HostInfo clusterInstanceHost) {
+    this.clusterInstanceHost = clusterInstanceHost;
   }
 
   /**
@@ -178,7 +165,14 @@ public class AuroraTopologyService implements TopologyService, CanCollectPerform
 
       if (latestTopologyInfo != null && latestTopologyInfo.hosts != null) {
         synchronized (cacheLock) {
-          clusterTopologyInfo = updateCache(clusterTopologyInfo, latestTopologyInfo);
+          if (clusterTopologyInfo == null) {
+            clusterTopologyInfo = new ClusterTopologyInfo();
+          }
+          clusterTopologyInfo.hosts = latestTopologyInfo.hosts;
+          clusterTopologyInfo.isMultiWriterCluster = latestTopologyInfo.isMultiWriterCluster;
+          clusterTopologyInfo.lastUpdated = Instant.now();
+          clusterTopologyInfo.downHosts = new HashSet<>();
+          topologyCache.put(this.clusterId, clusterTopologyInfo);
         }
       } else {
         return (clusterTopologyInfo == null || forceUpdate) ? null : clusterTopologyInfo.hosts;
@@ -190,11 +184,12 @@ public class AuroraTopologyService implements TopologyService, CanCollectPerform
 
   private boolean refreshNeeded(ClusterTopologyInfo info) {
     Instant lastUpdateTime = info.lastUpdated;
-    return lastUpdateTime == null || Duration.between(lastUpdateTime, Instant.now()).toMillis() > refreshRateInMilliseconds;
+    return lastUpdateTime == null
+        || Duration.between(lastUpdateTime, Instant.now()).toMillis() > refreshRateInMilliseconds;
   }
 
   /**
-   * Query the database for the cluster topology and use the results to record information about the topology.
+   * Obtain a cluster topology from database.
    *
    * @param conn A connection to database to fetch the latest topology.
    * @return Cluster topology details.
@@ -206,8 +201,29 @@ public class AuroraTopologyService implements TopologyService, CanCollectPerform
     try (Statement stmt = conn.createStatement()) {
       try (ResultSet resultSet = stmt.executeQuery(RETRIEVE_TOPOLOGY_SQL)) {
         result.hosts = new ArrayList<>();
-        result.hosts.add(null); // reserve space for a writer node\
-        processQueryResults(result, resultSet);
+        result.hosts.add(null); // reserve space for a writer node
+        int writerCount = 0;
+
+        int i = 1;
+        while (resultSet.next()) {
+          if (WRITER_SESSION_ID.equalsIgnoreCase(resultSet.getString(FIELD_SESSION_ID))) {
+            if (writerCount == 0) {
+              // store the first writer to its expected position [0]
+              result.hosts.set(
+                      ClusterAwareConnectionProxy.WRITER_CONNECTION_INDEX, createHost(resultSet));
+            } else {
+              // store other writers, if any, to reader position
+              // the goal is to not lose them
+              result.hosts.add(i, createHost(resultSet));
+              i++;
+            }
+            writerCount++;
+          } else {
+            result.hosts.add(i, createHost(resultSet));
+            i++;
+          }
+        }
+        result.isMultiWriterCluster = (writerCount > 1);
       }
     } catch (SQLException e) {
       // eat
@@ -217,55 +233,27 @@ public class AuroraTopologyService implements TopologyService, CanCollectPerform
       long currentTimeMs = System.currentTimeMillis();
       this.queryTopologyMetrics.registerQueryExecutionTime(currentTimeMs - startTimeMs);
     }
-    return result;
-  }
-
-  /**
-   * Process the results of the topology query to the database. This method creates a {@link HostInfo} object for each
-   * host in the topology, as well as storing some additional information about the cluster.
-   *
-   * @param clusterInfo A connection to database to fetch the latest topology.
-   * @param resultSet The {@link ResultSet} returned by the topology database query.
-   */
-  private void processQueryResults(ClusterTopologyInfo clusterInfo, ResultSet resultSet) throws SQLException {
-    int i = 1;
-    int writerCount = 0;
-    while (resultSet.next()) {
-      if (!WRITER_SESSION_ID.equalsIgnoreCase(resultSet.getString(FIELD_SESSION_ID))) {
-        clusterInfo.hosts.add(i, createHost(resultSet));
-        i++;
-        continue;
-      }
 
-      if (writerCount == 0) {
-        // store the first writer to its expected position [0]
-        clusterInfo.hosts.set(ClusterAwareConnectionProxy.WRITER_CONNECTION_INDEX, createHost(resultSet));
-      } else {
-        // append other writers, if any, to the end of the host list
-        clusterInfo.hosts.add(i, createHost(resultSet));
-        i++;
-      }
-      writerCount++;
-    }
-    clusterInfo.isMultiWriterCluster = (writerCount > 1);
+    return result;
   }
 
   private HostInfo createHost(ResultSet resultSet) throws SQLException {
     String hostEndpoint = getHostEndpoint(resultSet.getString(FIELD_SERVER_ID));
-    ConnectionUrl hostUrl = ConnectionUrl.getConnectionUrlInstance(
-                    getUrlFromEndpoint(
-                            hostEndpoint,
-                            this.clusterInstanceTemplate.getPort(),
-                            this.clusterInstanceTemplate.getDatabase()),
-                    new Properties());
+    ConnectionUrl hostUrl =
+        ConnectionUrl.getConnectionUrlInstance(
+            getUrlFromEndpoint(
+                hostEndpoint,
+                this.clusterInstanceHost.getPort(),
+                this.clusterInstanceHost.getDatabase()),
+            new Properties());
     return new HostInfo(
-            hostUrl,
-            hostEndpoint,
-            this.clusterInstanceTemplate.getPort(),
-            this.clusterInstanceTemplate.getUser(),
-            this.clusterInstanceTemplate.getPassword(),
-            this.clusterInstanceTemplate.isPasswordless(),
-            getPropertiesFromTopology(resultSet));
+        hostUrl,
+        hostEndpoint,
+        this.clusterInstanceHost.getPort(),
+        this.clusterInstanceHost.getUser(),
+        this.clusterInstanceHost.getPassword(),
+        this.clusterInstanceHost.isPasswordless(),
+        getPropertiesFromTopology(resultSet));
   }
 
   /**
@@ -275,25 +263,30 @@ public class AuroraTopologyService implements TopologyService, CanCollectPerform
    * @return Instance dns endpoint
    */
   private String getHostEndpoint(String nodeName) {
-    String host = this.clusterInstanceTemplate.getHost();
+    String host = this.clusterInstanceHost.getHost();
     return host.replace("?", nodeName);
   }
 
   private String getUrlFromEndpoint(String endpoint, int port, String dbname) {
     return String.format(
-            "%s//%s:%d/%s", ConnectionUrl.Type.SINGLE_CONNECTION_AWS.getScheme(), endpoint, port, dbname);
+        "%s//%s:%d/%s", ConnectionUrl.Type.SINGLE_CONNECTION_AWS.getScheme(), endpoint, port, dbname);
   }
 
   private Map<String, String> getPropertiesFromTopology(ResultSet resultSet) throws SQLException {
     Map<String, String> properties = new HashMap<>();
+
+    if (this.clusterInstanceHost != null) {
+      properties.putAll(this.clusterInstanceHost.getHostProperties());
+    }
+
     properties.put(TopologyServicePropertyKeys.INSTANCE_NAME, resultSet.getString(FIELD_SERVER_ID));
     properties.put(TopologyServicePropertyKeys.SESSION_ID, resultSet.getString(FIELD_SESSION_ID));
     properties.put(
-            TopologyServicePropertyKeys.LAST_UPDATED,
-            convertTimestampToString(resultSet.getTimestamp(FIELD_LAST_UPDATED)));
+        TopologyServicePropertyKeys.LAST_UPDATED,
+        convertTimestampToString(resultSet.getTimestamp(FIELD_LAST_UPDATED)));
     properties.put(
-            TopologyServicePropertyKeys.REPLICA_LAG,
-            Double.valueOf(resultSet.getDouble(FIELD_REPLICA_LAG)).toString());
+        TopologyServicePropertyKeys.REPLICA_LAG,
+        Double.valueOf(resultSet.getDouble(FIELD_REPLICA_LAG)).toString());
     return properties;
   }
 
@@ -301,28 +294,6 @@ public class AuroraTopologyService implements TopologyService, CanCollectPerform
     return timestamp == null ? null : timestamp.toString();
   }
 
-  /**
-   * Store the information for the topology in the cache, creating the information object if it did not previously exist
-   * in the cache.
-   *
-   * @param clusterTopologyInfo The cluster topology info that existed in the cache before the topology query. This
-   *          parameter will be null if no topology info for the cluster has been created in the cache yet.
-   * @param latestTopologyInfo The results of the current topology query
-   * @return The {@link ClusterTopologyInfo} stored in the cache by this method, representing the most up-to-date
-   *         information we have about the topology.
-   */
-  private ClusterTopologyInfo updateCache(ClusterTopologyInfo clusterTopologyInfo, ClusterTopologyInfo latestTopologyInfo) {
-    if (clusterTopologyInfo == null) {
-      clusterTopologyInfo = new ClusterTopologyInfo();
-    }
-    clusterTopologyInfo.hosts = latestTopologyInfo.hosts;
-    clusterTopologyInfo.isMultiWriterCluster = latestTopologyInfo.isMultiWriterCluster;
-    clusterTopologyInfo.lastUpdated = Instant.now();
-    clusterTopologyInfo.downHosts = new HashSet<>();
-    topologyCache.put(this.clusterId, clusterTopologyInfo);
-    return clusterTopologyInfo;
-  }
-
   /**
    * Get cached topology.
    *
diff --git a/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareConnectionProxy.java b/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareConnectionProxy.java
index adc9445..9cd1fe8 100644
--- a/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareConnectionProxy.java
+++ b/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareConnectionProxy.java
@@ -33,10 +33,10 @@ package com.mysql.cj.jdbc.ha.ca;
 import com.mysql.cj.Messages;
 import com.mysql.cj.NativeSession;
 import com.mysql.cj.conf.ConnectionUrl;
-import com.mysql.cj.conf.ConnectionUrlParser;
 import com.mysql.cj.conf.HostInfo;
 import com.mysql.cj.conf.PropertyKey;
 import com.mysql.cj.conf.RuntimeProperty;
+import com.mysql.cj.conf.ConnectionUrlParser;
 import com.mysql.cj.exceptions.CJCommunicationsException;
 import com.mysql.cj.exceptions.CJException;
 import com.mysql.cj.exceptions.MysqlErrorNumbers;
@@ -108,7 +108,6 @@ public class ClusterAwareConnectionProxy extends MultiHostConnectionProxy
   protected static final int WRITER_CONNECTION_INDEX = 0; // writer host is always stored at index 0
 
   protected int currentHostIndex = NO_CONNECTION_INDEX;
-  protected Map<String, String> initialConnectionProps;
   protected Boolean explicitlyReadOnly = null;
   protected boolean inTransaction = false;
   protected boolean explicitlyAutoCommit = true;
@@ -170,60 +169,11 @@ public class ClusterAwareConnectionProxy extends MultiHostConnectionProxy
         return result;
       }
     }
-
-  }
-  /**
-   * Checks if connection is associated with Aurora cluster and instantiates a new
-   * AuroraConnectionProxy if needed. Otherwise it returns a single-host connection.
-   *
-   * @param connectionUrl {@link ConnectionUrl} instance containing the lists of hosts available to
-   *     switch on.
-   * @throws SQLException if an error occurs
-   */
-  public static JdbcConnection autodetectClusterAndCreateProxyInstance(ConnectionUrl connectionUrl)
-          throws SQLException {
-
-    ClusterAwareConnectionProxy connProxy = new ClusterAwareConnectionProxy(connectionUrl);
-
-    if (connProxy.isFailoverEnabled()) {
-      return (JdbcConnection)
-              java.lang.reflect.Proxy.newProxyInstance(
-                      JdbcConnection.class.getClassLoader(),
-                      new Class<?>[] {JdbcConnection.class},
-                      connProxy);
-    }
-    // If failover is disabled, reset proxy settings from the connection.
-    connProxy.currentConnection.setProxy(null);
-    return connProxy.currentConnection;
-  }
-
-  /**
-   * Checks if cluster-aware failover is enabled/possible.
-   *
-   * @return true if cluster-aware failover is enabled
-   */
-  public boolean isFailoverEnabled() {
-    return this.enableFailoverSetting
-            && !this.isRdsProxy
-            && this.isClusterTopologyAvailable
-            && !this.isMultiWriterCluster;
   }
 
-  /**
-   * Instantiates a new AuroraConnectionProxy.
-   *
-   * @param connectionUrl {@link ConnectionUrl} instance containing the lists of hosts available to
-   *     switch on.
-   * @throws SQLException if an error occurs
-   */
-  public static JdbcConnection createProxyInstance(ConnectionUrl connectionUrl)
-          throws SQLException {
-    ClusterAwareConnectionProxy connProxy = new ClusterAwareConnectionProxy(connectionUrl);
-    return (JdbcConnection)
-            java.lang.reflect.Proxy.newProxyInstance(
-                    JdbcConnection.class.getClassLoader(),
-                    new Class<?>[] {JdbcConnection.class},
-                    connProxy);
+  @Override
+  protected InvocationHandler getNewJdbcInterfaceProxy(Object toProxy) {
+    return new JdbcInterfaceProxy(toProxy);
   }
 
   /**
@@ -235,11 +185,10 @@ public class ClusterAwareConnectionProxy extends MultiHostConnectionProxy
    */
   public ClusterAwareConnectionProxy(ConnectionUrl connectionUrl) throws SQLException {
     super(connectionUrl);
-    this.initialConnectionProps = connectionUrl.getMainHost().getHostProperties();
     initSettings(connectionUrl);
     initLogger(connectionUrl);
 
-    AuroraTopologyService topologyService = new AuroraTopologyService(this.log);
+    AuroraTopologyService topologyService = new AuroraTopologyService();
     topologyService.setPerformanceMetricsEnabled(this.gatherPerfMetricsSetting);
     topologyService.setRefreshRate(this.clusterTopologyRefreshRateMsSetting);
     this.topologyService = topologyService;
@@ -249,7 +198,6 @@ public class ClusterAwareConnectionProxy extends MultiHostConnectionProxy
         new ClusterAwareReaderFailoverHandler(
             this.topologyService,
             this.connectionProvider,
-            this.initialConnectionProps,
             this.failoverTimeoutMsSetting,
             this.failoverReaderConnectTimeoutMsSetting,
             this.log);
@@ -258,13 +206,12 @@ public class ClusterAwareConnectionProxy extends MultiHostConnectionProxy
             this.topologyService,
             this.connectionProvider,
             this.readerFailoverHandler,
-            this.initialConnectionProps,
             this.failoverTimeoutMsSetting,
             this.failoverClusterTopologyRefreshRateMsSetting,
             this.failoverWriterReconnectIntervalMsSetting,
             this.log);
 
-    initProxy(connectionUrl);
+    initClusterInfo(connectionUrl);
   }
 
   ClusterAwareConnectionProxy(
@@ -275,7 +222,6 @@ public class ClusterAwareConnectionProxy extends MultiHostConnectionProxy
       ReaderFailoverHandler readerFailoverHandler)
       throws SQLException {
     super(connectionUrl);
-    this.initialConnectionProps = connectionUrl.getMainHost().getHostProperties();
     initSettings(connectionUrl);
     initLogger(connectionUrl);
 
@@ -290,7 +236,49 @@ public class ClusterAwareConnectionProxy extends MultiHostConnectionProxy
     this.writerFailoverHandler = writerFailoverHandler;
     this.readerFailoverHandler = readerFailoverHandler;
 
-    initProxy(connectionUrl);
+    initClusterInfo(connectionUrl);
+  }
+
+  /**
+   * Checks if connection is associated with Aurora cluster and instantiates a new
+   * AuroraConnectionProxy if needed. Otherwise it returns a single-host connection.
+   *
+   * @param connectionUrl {@link ConnectionUrl} instance containing the lists of hosts available to
+   *     switch on.
+   * @throws SQLException if an error occurs
+   */
+  public static JdbcConnection autodetectClusterAndCreateProxyInstance(ConnectionUrl connectionUrl)
+      throws SQLException {
+
+    ClusterAwareConnectionProxy connProxy = new ClusterAwareConnectionProxy(connectionUrl);
+
+    if (connProxy.isFailoverEnabled()) {
+      return (JdbcConnection)
+          java.lang.reflect.Proxy.newProxyInstance(
+              JdbcConnection.class.getClassLoader(),
+              new Class<?>[] {JdbcConnection.class},
+              connProxy);
+    }
+    // If failover is disabled, reset proxy settings from the connection.
+    connProxy.currentConnection.setProxy(null);
+    return connProxy.currentConnection;
+  }
+
+  /**
+   * Instantiates a new AuroraConnectionProxy.
+   *
+   * @param connectionUrl {@link ConnectionUrl} instance containing the lists of hosts available to
+   *     switch on.
+   * @throws SQLException if an error occurs
+   */
+  public static JdbcConnection createProxyInstance(ConnectionUrl connectionUrl)
+      throws SQLException {
+    ClusterAwareConnectionProxy connProxy = new ClusterAwareConnectionProxy(connectionUrl);
+    return (JdbcConnection)
+        java.lang.reflect.Proxy.newProxyInstance(
+            JdbcConnection.class.getClassLoader(),
+            new Class<?>[] {JdbcConnection.class},
+            connProxy);
   }
 
   protected synchronized void initSettings(ConnectionUrl connectionUrl) throws SQLException {
@@ -333,140 +321,256 @@ public class ClusterAwareConnectionProxy extends MultiHostConnectionProxy
     }
   }
 
-  protected void initProxy(ConnectionUrl connUrl) throws SQLException {
+  /**
+   * Checks if proxy is connected to cluster that can report its topology.
+   *
+   * @return true if proxy is connected to cluster that can report its topology
+   */
+  public boolean isClusterTopologyAvailable() {
+    return this.isClusterTopologyAvailable;
+  }
+
+  /**
+   * Checks if proxy is connected to RDS-hosted cluster.
+   *
+   * @return true if proxy is connected to RDS-hosted cluster
+   */
+  public boolean isRds() {
+    return this.isRds;
+  }
+
+  /**
+   * Checks if proxy is connected to cluster through RDS proxy.
+   *
+   * @return true if proxy is connected to cluster through RDS proxy
+   */
+  public boolean isRdsProxy() {
+    return this.isRdsProxy;
+  }
+
+  /**
+   * Checks if proxy is connected to multi-writer cluster.
+   *
+   * @return true if proxy is connected to multi-writer cluster
+   */
+  public boolean isMultiWriterCluster() {
+    return this.isMultiWriterCluster;
+  }
+
+  /**
+   * Checks if cluster-aware failover is enabled/possible.
+   *
+   * @return true if cluster-aware failover is enabled
+   */
+  public boolean isFailoverEnabled() {
+    return this.enableFailoverSetting
+        && !this.isRdsProxy
+        && this.isClusterTopologyAvailable
+        && !this.isMultiWriterCluster;
+  }
+
+  protected void initClusterInfo(ConnectionUrl connUrl) throws SQLException {
     if (!this.enableFailoverSetting) {
       // Use a standard default connection - no further initialization required
       this.currentConnection = this.connectionProvider.connect(connUrl.getMainHost());
       return;
     }
+    this.log.logDebug(Messages.getString("ClusterAwareConnectionProxy.9"));
 
-    this.log.logDebug(Messages.getString("ClusterAwareConnectionProxy.8"));
     this.log.logTrace(
-            Messages.getString(
-                    "ClusterAwareConnectionProxy.9", new Object[] {"clusterId", this.clusterIdSetting}));
+        Messages.getString(
+            "ClusterAwareConnectionProxy.10", new Object[] {"clusterId", this.clusterIdSetting}));
     this.log.logTrace(
-            Messages.getString(
-                    "ClusterAwareConnectionProxy.9",
-                    new Object[] {"clusterInstanceHostPattern", this.clusterInstanceHostPatternSetting}));
+        Messages.getString(
+            "ClusterAwareConnectionProxy.10",
+            new Object[] {"clusterInstanceHostPattern", this.clusterInstanceHostPatternSetting}));
 
     HostInfo mainHost = this.connectionUrl.getMainHost();
+
     if (!StringUtils.isNullOrEmpty(this.clusterInstanceHostPatternSetting)) {
-      initFromHostPatternSetting(connUrl, mainHost);
-    } else if (IpAddressUtils.isIPv4(mainHost.getHost())
-            || IpAddressUtils.isIPv6(mainHost.getHost())) {
-      initExpectingNoTopology(connUrl, mainHost);
-    } else {
-      identifyRdsType(mainHost.getHost());
-      if (!this.isRds) {
-        initExpectingNoTopology(connUrl, mainHost);
-      } else {
-        initFromConnectionString(connUrl, mainHost);
+
+      ConnectionUrlParser.Pair<String, Integer> pair =
+          ConnectionUrlParser.parseHostPortPair(this.clusterInstanceHostPatternSetting);
+      if (pair == null) {
+        // "Invalid value in 'clusterInstanceHostPattern' configuration property."
+        throw new SQLException(Messages.getString("ClusterAwareConnectionProxy.5"));
       }
-    }
-  }
+      String instanceHostPattern = pair.left;
+      int instanceHostPort = pair.right != HostInfo.NO_PORT ? pair.right : mainHost.getPort();
 
-  private void initFromHostPatternSetting(ConnectionUrl connUrl, HostInfo mainHost) throws SQLException {
-    ConnectionUrlParser.Pair<String, Integer> pair = getHostPortPairFromHostPatternSetting();
-    String instanceHostPattern = pair.left;
-    int instanceHostPort = pair.right != HostInfo.NO_PORT ? pair.right : mainHost.getPort();
+      if (!isDnsPatternValid(instanceHostPattern)) {
+        // "Invalid value in 'clusterInstanceHostPattern' configuration property."
+        this.log.logError(Messages.getString("ClusterAwareConnectionProxy.5"));
+        throw new SQLException(Messages.getString("ClusterAwareConnectionProxy.5"));
+      }
 
-    // Instance host info is similar to original main host except host and port which come from the configuration property
-    setClusterId(instanceHostPattern, instanceHostPort);
-    this.topologyService.setClusterInstanceTemplate(
-            createClusterInstanceTemplate(mainHost, instanceHostPattern, instanceHostPort));
-    createConnectionAndInitializeTopology(connUrl);
-  }
+      // Instance host info is similar to original main host except host and port which go from
+      // configuration property
+      this.topologyService.setClusterInstanceHost(
+          createClusterInstanceHost(mainHost, instanceHostPattern, instanceHostPort));
+      this.log.logTrace(
+          Messages.getString(
+              "ClusterAwareConnectionProxy.11",
+              new Object[] {instanceHostPattern, instanceHostPort}));
 
-  private ConnectionUrlParser.Pair<String, Integer> getHostPortPairFromHostPatternSetting() throws SQLException {
-    ConnectionUrlParser.Pair<String, Integer> pair = ConnectionUrlParser.parseHostPortPair(
-            this.clusterInstanceHostPatternSetting);
-    if (pair == null) {
-      // "Invalid value in 'clusterInstanceHostPattern' configuration property."
-      throw new SQLException(Messages.getString("ClusterAwareConnectionProxy.5"));
-    }
+      this.isRds = isRdsDns(instanceHostPattern);
+      this.log.logTrace(
+          Messages.getString("ClusterAwareConnectionProxy.12", new Object[] {"isRds", this.isRds}));
 
-    validateHostPatternSetting(pair.left);
-    return pair;
-  }
+      this.isRdsProxy = isRdsProxyDns(instanceHostPattern);
+      this.log.logTrace(
+          Messages.getString(
+              "ClusterAwareConnectionProxy.12", new Object[] {"isRdsProxy", this.isRdsProxy}));
 
-  private void validateHostPatternSetting(String hostPattern) throws SQLException {
-    if (!isDnsPatternValid(hostPattern)) {
-      // "Invalid value in 'clusterInstanceHostPattern' configuration property."
-      this.log.logError(Messages.getString("ClusterAwareConnectionProxy.5"));
-      throw new SQLException(Messages.getString("ClusterAwareConnectionProxy.5"));
-    }
+      boolean isRdsCustomCluster = isRdsCustomClusterDns(instanceHostPattern);
+      this.log.logTrace(
+          Messages.getString(
+              "ClusterAwareConnectionProxy.12",
+              new Object[] {"isRdsCustomCluster", isRdsCustomCluster}));
+
+      if (this.isRdsProxy) {
+        // "RDS Proxy url can't be used as an instance pattern."
+        this.log.logError(Messages.getString("ClusterAwareConnectionProxy.8"));
+        throw new SQLException(Messages.getString("ClusterAwareConnectionProxy.8"));
+      }
 
-    identifyRdsType(hostPattern);
-    if(this.isRdsProxy) {
-      // "RDS Proxy url can't be used as an instance pattern."
-      this.log.logError(Messages.getString("ClusterAwareConnectionProxy.7"));
-      throw new SQLException(Messages.getString("ClusterAwareConnectionProxy.7"));
-    }
+      if (isRdsCustomCluster) {
+        // "RDS Custom Cluster endpoint can't be used as an instance pattern."
+        this.log.logError(Messages.getString("ClusterAwareConnectionProxy.24"));
+        throw new SQLException(Messages.getString("ClusterAwareConnectionProxy.24"));
+      }
 
-    if(isRdsCustomClusterDns(hostPattern)) {
-      // "RDS Custom Cluster endpoint can't be used as an instance pattern."
-      this.log.logError(Messages.getString("ClusterAwareConnectionProxy.18"));
-      throw new SQLException(Messages.getString("ClusterAwareConnectionProxy.18"));
-    }
-  }
+      if (!StringUtils.isNullOrEmpty(this.clusterIdSetting)) {
+        this.topologyService.setClusterId(this.clusterIdSetting);
+        this.log.logTrace(
+            Messages.getString(
+                "ClusterAwareConnectionProxy.13",
+                new Object[] {"clusterId", this.clusterIdSetting}));
+      } else if (this.isRds) {
+        // If it's a cluster endpoint, or a reader cluster endpoint, then let's use as cluster
+        // identification
+        String clusterRdsHostUrl = getRdsClusterHostUrl(instanceHostPattern);
+        if (!StringUtils.isNullOrEmpty(clusterRdsHostUrl)) {
+          this.topologyService.setClusterId(clusterRdsHostUrl + ":" + instanceHostPort);
+          this.log.logTrace(
+              Messages.getString(
+                  "ClusterAwareConnectionProxy.13",
+                  new Object[] {"clusterId", clusterRdsHostUrl + ":" + instanceHostPort}));
+        }
+      }
 
-  private boolean isDnsPatternValid(String pattern) {
-    return pattern.contains("?");
-  }
+      createConnectionAndInitializeTopology(connUrl);
+    } else if (IpAddressUtils.isIPv4(mainHost.getHost())
+        || IpAddressUtils.isIPv6(mainHost.getHost())) {
+      this.topologyService.setClusterInstanceHost(createClusterInstanceHost(mainHost, mainHost.getHost(), mainHost.getPort()));
+      this.log.logTrace(
+          Messages.getString(
+              "ClusterAwareConnectionProxy.11",
+              new Object[] {mainHost.getHost(), mainHost.getPort()}));
 
-  private void identifyRdsType(String host) {
-    this.isRds = isRdsDns(host);
-    this.log.logTrace(
-            Messages.getString("ClusterAwareConnectionProxy.10", new Object[] {"isRds", this.isRds}));
+      if (!StringUtils.isNullOrEmpty(this.clusterIdSetting)) {
+        this.topologyService.setClusterId(this.clusterIdSetting);
+        this.log.logTrace(
+            Messages.getString(
+                "ClusterAwareConnectionProxy.13",
+                new Object[] {"clusterId", this.clusterIdSetting}));
+      }
 
-    this.isRdsProxy = isRdsProxyDns(host);
-    this.log.logTrace(
+      createConnectionAndInitializeTopology(connUrl);
+
+      if (this.isClusterTopologyAvailable) {
+        // "'clusterInstanceHostPattern' configuration property is required when IP address is used
+        // to connect to cluster."
+        this.log.logError(Messages.getString("ClusterAwareConnectionProxy.6"));
+        throw new SQLException(Messages.getString("ClusterAwareConnectionProxy.6"));
+      }
+
+      this.isRds = false; // actually we don't know
+      this.log.logTrace(
+          Messages.getString("ClusterAwareConnectionProxy.12", new Object[] {"isRds", this.isRds}));
+
+      this.isRdsProxy = false; // actually we don't know
+      this.log.logTrace(
+          Messages.getString(
+              "ClusterAwareConnectionProxy.12", new Object[] {"isRdsProxy", this.isRdsProxy}));
+
+    } else {
+
+      this.isRds = isRdsDns(mainHost.getHost());
+      this.log.logTrace(
+          Messages.getString("ClusterAwareConnectionProxy.12", new Object[] {"isRds", this.isRds}));
+
+      this.isRdsProxy = isRdsProxyDns(mainHost.getHost());
+      this.log.logTrace(
+          Messages.getString(
+              "ClusterAwareConnectionProxy.12", new Object[] {"isRdsProxy", this.isRdsProxy}));
+
+      if (!this.isRds) {
+        // it's not RDS, maybe custom domain (CNAME)
+        this.topologyService.setClusterInstanceHost(createClusterInstanceHost(mainHost, mainHost.getHost(), mainHost.getPort()));
+        this.log.logTrace(
             Messages.getString(
-                    "ClusterAwareConnectionProxy.10", new Object[] {"isRdsProxy", this.isRdsProxy}));
-  }
+                "ClusterAwareConnectionProxy.11",
+                new Object[] {mainHost.getHost(), mainHost.getPort()}));
 
-  private void initExpectingNoTopology(ConnectionUrl connUrl, HostInfo mainHost) throws SQLException {
-    setClusterId(mainHost.getHost(), mainHost.getPort());
-    this.topologyService.setClusterInstanceTemplate(
-            createClusterInstanceTemplate(mainHost, mainHost.getHost(), mainHost.getPort()));
-    createConnectionAndInitializeTopology(connUrl);
+        if (!StringUtils.isNullOrEmpty(this.clusterIdSetting)) {
+          this.topologyService.setClusterId(this.clusterIdSetting);
+          this.log.logTrace(
+              Messages.getString(
+                  "ClusterAwareConnectionProxy.13",
+                  new Object[] {"clusterId", this.clusterIdSetting}));
+        }
 
-    if (this.isClusterTopologyAvailable) {
-      // "The 'clusterInstanceHostPattern' configuration property is required when an IP address or custom domain is used to connect to the cluster."
-      this.log.logError(Messages.getString("ClusterAwareConnectionProxy.6"));
-      throw new SQLException(Messages.getString("ClusterAwareConnectionProxy.6"));
-    }
-  }
+        createConnectionAndInitializeTopology(connUrl);
 
-  private void initFromConnectionString(ConnectionUrl connUrl, HostInfo mainHost) throws SQLException {
-    String rdsInstanceHostPattern = getRdsInstanceHostPattern(mainHost.getHost());
-    if(rdsInstanceHostPattern == null) {
-      this.log.logError(Messages.getString("ClusterAwareConnectionProxy.20"));
-      throw new SQLException(Messages.getString("ClusterAwareConnectionProxy.20"));
-    }
+        if (this.isClusterTopologyAvailable) {
+          // "The provided connection string appears to be a custom domain. The driver requires the
+          // 'clusterInstanceHostPattern' configuration property to be set for custom domains."
+          this.log.logError(Messages.getString("ClusterAwareConnectionProxy.7"));
+          throw new SQLException(Messages.getString("ClusterAwareConnectionProxy.7"));
+        }
+      } else {
+        // It's RDS
+        String rdsInstanceHostPattern = getRdsInstanceHostPattern(mainHost.getHost());
+        this.topologyService.setClusterInstanceHost(
+            createClusterInstanceHost(mainHost, rdsInstanceHostPattern, mainHost.getPort()));
+        this.log.logTrace(
+            Messages.getString(
+                "ClusterAwareConnectionProxy.11",
+                new Object[] {rdsInstanceHostPattern, mainHost.getPort()}));
 
-    setClusterId(mainHost.getHost(), mainHost.getPort());
-    this.topologyService.setClusterInstanceTemplate(
-            createClusterInstanceTemplate(mainHost, rdsInstanceHostPattern, mainHost.getPort()));
-    createConnectionAndInitializeTopology(connUrl);
-  }
-
-  private void setClusterId(String host, int port) {
-    if (!StringUtils.isNullOrEmpty(this.clusterIdSetting)) {
-      this.topologyService.setClusterId(this.clusterIdSetting);
-    } else if (this.isRdsProxy) {
-      // Each proxy is associated with a single cluster so it's safe to use RDS Proxy Url as cluster identification
-      this.topologyService.setClusterId(host + ":" + port);
-    } else if (this.isRds) {
-      // If it's a cluster endpoint, or a reader cluster endpoint, then let's use it as the cluster ID
-      String clusterRdsHostUrl = getRdsClusterHostUrl(host);
-      if (!StringUtils.isNullOrEmpty(clusterRdsHostUrl)) {
-        this.topologyService.setClusterId(clusterRdsHostUrl + ":" + port);
+        if (!StringUtils.isNullOrEmpty(this.clusterIdSetting)) {
+          this.topologyService.setClusterId(this.clusterIdSetting);
+          this.log.logTrace(
+              Messages.getString(
+                  "ClusterAwareConnectionProxy.13",
+                  new Object[] {"clusterId", this.clusterIdSetting}));
+        } else if (this.isRdsProxy) {
+          // Each proxy is associated with a single cluster so it's safe to use RDS Proxy Url as
+          // cluster identification
+          this.topologyService.setClusterId(mainHost.getHost() + ":" + mainHost.getPort());
+          this.log.logTrace(
+              Messages.getString(
+                  "ClusterAwareConnectionProxy.13",
+                  new Object[] {"clusterId", mainHost.getHost() + ":" + mainHost.getPort()}));
+        } else {
+          // If it's cluster endpoint or reader cluster endpoint,
+          // then let's use as cluster identification
+          String clusterRdsHostUrl = getRdsClusterHostUrl(mainHost.getHost());
+          if (!StringUtils.isNullOrEmpty(clusterRdsHostUrl)) {
+            this.topologyService.setClusterId(clusterRdsHostUrl + ":" + mainHost.getPort());
+            this.log.logTrace(
+                Messages.getString(
+                    "ClusterAwareConnectionProxy.13",
+                    new Object[] {"clusterId", clusterRdsHostUrl + ":" + mainHost.getPort()}));
+          }
+        }
+        createConnectionAndInitializeTopology(connUrl);
       }
     }
   }
 
-  private HostInfo createClusterInstanceTemplate(HostInfo mainHost, String host, int port) {
+  private HostInfo createClusterInstanceHost(HostInfo mainHost, String host, int port) {
     Map<String, String> properties = new HashMap<>(mainHost.getHostProperties());
     properties.put(PropertyKey.connectTimeout.getKeyName(), String.valueOf(this.failoverConnectTimeoutMs));
     properties.put(PropertyKey.socketTimeout.getKeyName(), String.valueOf(this.failoverSocketTimeoutMs));
@@ -495,17 +599,13 @@ public class ClusterAwareConnectionProxy extends MultiHostConnectionProxy
     }
   }
 
-  private boolean isExplicitlyReadOnly() {
-    return this.explicitlyReadOnly != null && this.explicitlyReadOnly;
-  }
-
   private synchronized void createInitialConnection(ConnectionUrl connUrl) throws SQLException {
     String host = connUrl.getMainHost().getHost();
     if (isRdsClusterDns(host)) {
       this.explicitlyReadOnly = isReaderClusterDns(host);
       this.log.logTrace(
               Messages.getString(
-                      "ClusterAwareConnectionProxy.10",
+                      "ClusterAwareConnectionProxy.12",
                       new Object[] {"explicitlyReadOnly", this.explicitlyReadOnly}));
 
       try {
@@ -516,32 +616,13 @@ public class ClusterAwareConnectionProxy extends MultiHostConnectionProxy
     }
 
     if (!isConnected()) {
-      // Either URL was not a cluster endpoint or cached topology did not exist - connect directly to URL
+      // Either URL was not a cluster endpoint or cached topology did not exist - connect directly
+      // to URL
       this.currentConnection = this.connectionProvider.connect(connUrl.getMainHost());
       setConnectionProxy(this.currentConnection);
     }
   }
 
-  /**
-   * Checks if there is a underlying connection for this proxy.
-   *
-   * @return true if there is a connection
-   */
-  synchronized boolean isConnected() {
-    return this.currentHostIndex != NO_CONNECTION_INDEX;
-  }
-
-  protected void setConnectionProxy(JdbcConnection conn) {
-    JdbcConnection topmostProxy = getProxy();
-    if (topmostProxy != this.thisAsConnection) {
-      conn.setProxy(
-              this
-                      .thisAsConnection);
-      // First call sets this connection as underlying connection parent proxy (its creator).
-    }
-    conn.setProxy(topmostProxy); // Set the topmost proxy in the underlying connection.
-  }
-
   private void attemptConnectionUsingCachedTopology() throws SQLException {
     this.hosts = topologyService.getCachedTopology();
     if (this.hosts == null || this.hosts.isEmpty()) {
@@ -591,24 +672,14 @@ public class ClusterAwareConnectionProxy extends MultiHostConnectionProxy
     }
   }
 
-  private boolean clusterContainsReader() {
-    return this.hosts.size() > 1;
-  }
-
-  private int getRandomReaderIndex() {
-    int max = this.hosts.size() - 1;
-    int min = WRITER_CONNECTION_INDEX + 1;
-    return (int) (Math.random() * ((max - min) + 1)) + min;
-  }
-
   private synchronized void initTopology() {
     this.hosts = this.topologyService.getTopology(this.currentConnection, false);
     this.isClusterTopologyAvailable = this.hosts != null && !this.hosts.isEmpty();
     this.isMultiWriterCluster = this.topologyService.isMultiWriterCluster();
     this.log.logTrace(
-            Messages.getString(
-                    "ClusterAwareConnectionProxy.10",
-                    new Object[] {"isClusterTopologyAvailable", this.isClusterTopologyAvailable}));
+        Messages.getString(
+            "ClusterAwareConnectionProxy.12",
+            new Object[] {"isClusterTopologyAvailable", this.isClusterTopologyAvailable}));
 
     if (this.isFailoverEnabled()) {
       logTopology();
@@ -622,7 +693,7 @@ public class ClusterAwareConnectionProxy extends MultiHostConnectionProxy
       return;
     }
 
-    if (validWriterConnection()) {
+    if (!invalidWriterConnection()) {
       if (this.gatherPerfMetricsSetting) {
         this.metrics.registerInvalidInitialConnection(false);
       }
@@ -651,38 +722,220 @@ public class ClusterAwareConnectionProxy extends MultiHostConnectionProxy
     }
   }
 
-  private int getHostIndex(HostInfo host) {
-    if (host == null) {
-      return NO_CONNECTION_INDEX;
-    }
-    for (int i = 0; i < this.hosts.size(); i++) {
-      HostInfo potentialMatch = this.hosts.get(i);
-      if (potentialMatch != null && potentialMatch.equalHostPortPair(host)) {
-        return i;
-      }
-    }
-    return NO_CONNECTION_INDEX;
+  private boolean isDnsPatternValid(String pattern) {
+    return pattern.contains("?");
   }
 
-  /**
-   * Local implementation for the new connection picker.
-   */
-  @Override
-  protected synchronized void pickNewConnection() throws SQLException {
-    if (this.isClosed && this.closedExplicitly) {
-      this.log.logDebug(Messages.getString("ClusterAwareConnectionProxy.14"));
-      return;
-    }
+  private boolean isRdsDns(String host) {
+    Matcher matcher = auroraDnsPattern.matcher(host);
+    return matcher.find();
+  }
 
-    if (isConnected()) {
-      failover(this.currentHostIndex);
-      return;
-    }
+  private boolean isRdsProxyDns(String host) {
+    Matcher matcher = auroraProxyDnsPattern.matcher(host);
+    return matcher.find();
+  }
 
-    if (shouldAttemptReaderConnection()) {
-      failoverReader(NO_CONNECTION_INDEX);
-      return;
-    }
+  private boolean isRdsCustomClusterDns(String host) {
+    Matcher matcher = auroraCustomClusterPattern.matcher(host);
+    return matcher.find();
+  }
+
+  private String getRdsClusterHostUrl(String host) {
+    Matcher matcher = auroraDnsPattern.matcher(host);
+    String clusterKeyword = getClusterKeyword(matcher);
+    if ("cluster-".equalsIgnoreCase(clusterKeyword)
+        || "cluster-ro-".equalsIgnoreCase(clusterKeyword)) {
+      return matcher.group(1) + ".cluster-" + matcher.group(3); // always RDS cluster endpoint
+    }
+    return null;
+  }
+
+  private String getRdsInstanceHostPattern(String host) {
+    Matcher matcher = auroraDnsPattern.matcher(host);
+    if (matcher.find()) {
+      return "?." + matcher.group(3);
+    }
+    return null;
+  }
+
+  private boolean isRdsClusterDns(String host) {
+    Matcher matcher = auroraDnsPattern.matcher(host);
+    String clusterKeyword = getClusterKeyword(matcher);
+    return "cluster-".equalsIgnoreCase(clusterKeyword)
+        || "cluster-ro-".equalsIgnoreCase(clusterKeyword);
+  }
+
+  private boolean isReaderClusterDns(String host) {
+    Matcher matcher = auroraDnsPattern.matcher(host);
+    return "cluster-ro-".equalsIgnoreCase(getClusterKeyword(matcher));
+  }
+
+  private String getClusterKeyword(Matcher matcher) {
+    if (matcher.find()
+        && matcher.group(2) != null
+        && matcher.group(1) != null
+        && !matcher.group(1).isEmpty()) {
+      return matcher.group(2);
+    }
+    return null;
+  }
+
+  private int getRandomReaderIndex() {
+    int max = this.hosts.size() - 1;
+    int min = WRITER_CONNECTION_INDEX + 1;
+    return (int) (Math.random() * ((max - min) + 1)) + min;
+  }
+
+  private boolean invalidWriterConnection() {
+    return this.explicitlyReadOnly != null
+        && !this.explicitlyReadOnly
+        && !isWriterHostIndex(this.currentHostIndex);
+  }
+
+  private boolean isExplicitlyReadOnly() {
+    return this.explicitlyReadOnly != null && this.explicitlyReadOnly;
+  }
+
+  private boolean shouldPerformWriterFailover() {
+    return this.explicitlyReadOnly == null || !this.explicitlyReadOnly;
+  }
+
+  private void logTopology() {
+    StringBuilder msg = new StringBuilder();
+    for (int i = 0; i < this.hosts.size(); i++) {
+      HostInfo hostInfo = this.hosts.get(i);
+      msg.append("\n   [")
+              .append(i)
+              .append("]: ")
+              .append(hostInfo == null ? "<null>" : hostInfo.getHost());
+    }
+    this.log.logTrace(
+        Messages.getString("ClusterAwareConnectionProxy.16", new Object[] {msg.toString()}));
+  }
+
+  /**
+   * Invalidates the current connection.
+   *
+   * @throws SQLException if an error occurs
+   */
+  @Override
+  protected synchronized void invalidateCurrentConnection() throws SQLException {
+    if (this.inTransaction) {
+      try {
+        this.currentConnection.rollback();
+      } catch (SQLException e) {
+        // eat
+      }
+    }
+    super.invalidateConnection(this.currentConnection);
+  }
+
+  /**
+   * Deals with InvocationException from proxied objects.
+   *
+   * @param e The Exception instance to check.
+   * @throws SQLException if an error occurs
+   * @throws Throwable if an error occurs
+   * @throws InvocationTargetException if an error occurs
+   */
+  @Override
+  protected synchronized void dealWithInvocationException(InvocationTargetException e)
+      throws SQLException, Throwable, InvocationTargetException {
+    dealWithOriginalException(e.getTargetException(), e);
+  }
+
+  protected void dealWithIllegalStateException(IllegalStateException e) throws Throwable {
+    dealWithOriginalException(e.getCause(), e);
+  }
+
+  private void dealWithOriginalException(Throwable originalException, Exception wrapperException) throws Throwable {
+    if (originalException != null) {
+      this.log.logTrace(Messages.getString("ClusterAwareConnectionProxy.17"), originalException);
+      if (this.lastExceptionDealtWith != originalException && shouldExceptionTriggerConnectionSwitch(originalException)) {
+        if (this.gatherPerfMetricsSetting) {
+          long currentTimeMs = System.currentTimeMillis();
+          this.metrics.registerFailureDetectionTime(currentTimeMs - this.invokeStartTimeMs);
+          this.invokeStartTimeMs = 0;
+          this.failoverStartTimeMs = currentTimeMs;
+        }
+        invalidateCurrentConnection();
+        pickNewConnection();
+        this.lastExceptionDealtWith = originalException;
+      }
+      throw originalException;
+    }
+    throw wrapperException;
+  }
+
+  /*
+   * Local implementation for the connection switch exception checker.
+   */
+  @Override
+  protected boolean shouldExceptionTriggerConnectionSwitch(Throwable t) {
+
+    if (!isFailoverEnabled()) {
+      this.log.logDebug(Messages.getString("ClusterAwareConnectionProxy.18"));
+      return false;
+    }
+
+    String sqlState = null;
+    if (t instanceof CommunicationsException || t instanceof CJCommunicationsException) {
+      return true;
+    } else if (t instanceof SQLException) {
+      sqlState = ((SQLException) t).getSQLState();
+    } else if (t instanceof CJException) {
+      if (t.getCause() instanceof EOFException) { // Can not read response from server
+        return true;
+      }
+      if (t.getCause() instanceof SSLException) { // Incomplete packets from server may cause SSL communication issues
+        return true;
+      }
+      sqlState = ((CJException) t).getSQLState();
+    }
+
+    if (sqlState != null) {
+      // connection error
+      return sqlState.startsWith("08");
+    }
+
+    return false;
+  }
+
+  /** Checks if current connection is to a master (writer) host. */
+  @Override
+  protected boolean isSourceConnection() {
+    return isWriterHostIndex(this.currentHostIndex);
+  }
+
+  /**
+   * Checks if there is a underlying connection for this proxy.
+   *
+   * @return true if there is a connection
+   */
+  synchronized boolean isConnected() {
+    return this.currentHostIndex != NO_CONNECTION_INDEX;
+  }
+
+  /*
+   * Local implementation for the new connection picker.
+   */
+  @Override
+  protected synchronized void pickNewConnection() throws SQLException {
+    if (this.isClosed && this.closedExplicitly) {
+      this.log.logDebug(Messages.getString("ClusterAwareConnectionProxy.19"));
+      return;
+    }
+
+    if (isConnected()) {
+      failover(this.currentHostIndex);
+      return;
+    }
+
+    if (shouldAttemptReaderConnection()) {
+      failoverReader(NO_CONNECTION_INDEX);
+      return;
+    }
 
     if (this.hosts.get(WRITER_CONNECTION_INDEX) == null) {
       failover(WRITER_CONNECTION_INDEX);
@@ -703,6 +956,23 @@ public class ClusterAwareConnectionProxy extends MultiHostConnectionProxy
     return isExplicitlyReadOnly() && clusterContainsReader();
   }
 
+  private boolean clusterContainsReader() {
+    return this.hosts.size() > 1;
+  }
+
+  private int getHostIndex(HostInfo host) {
+    if (host == null) {
+      return NO_CONNECTION_INDEX;
+    }
+    for (int i = 0; i < this.hosts.size(); i++) {
+      HostInfo potentialMatch = this.hosts.get(i);
+      if (potentialMatch != null && potentialMatch.equalHostPortPair(host)) {
+        return i;
+      }
+    }
+    return NO_CONNECTION_INDEX;
+  }
+
   /**
    * Connects this dynamic failover connection proxy to the host pointed out by the given host
    * index.
@@ -714,22 +984,22 @@ public class ClusterAwareConnectionProxy extends MultiHostConnectionProxy
     try {
       switchCurrentConnectionTo(hostIndex, createConnectionForHostIndex(hostIndex));
       this.log.logDebug(
-              Messages.getString(
-                      "ClusterAwareConnectionProxy.15", new Object[] {this.hosts.get(hostIndex)}));
+          Messages.getString(
+              "ClusterAwareConnectionProxy.20", new Object[] {this.hosts.get(hostIndex)}));
     } catch (SQLException e) {
       if (this.currentConnection != null) {
         HostInfo host = this.hosts.get(hostIndex);
         StringBuilder msg =
-                new StringBuilder("Connection to ")
-                        .append(isWriterHostIndex(hostIndex) ? "writer" : "reader")
-                        .append(" host '")
-                        .append(host == null ? "<null>" : host.getHostPortPair())
-                        .append("' failed");
+            new StringBuilder("Connection to ")
+                .append(isWriterHostIndex(hostIndex) ? "writer" : "reader")
+                .append(" host '")
+                .append(host == null ? "<null>" : host.getHostPortPair())
+                .append("' failed");
         try {
           this.log.logWarn(msg.toString(), e);
         } catch (CJException ex) {
           throw SQLExceptionsMapping.translateException(
-                  e, this.currentConnection.getExceptionInterceptor());
+              e, this.currentConnection.getExceptionInterceptor());
         }
       }
       throw e;
@@ -737,13 +1007,41 @@ public class ClusterAwareConnectionProxy extends MultiHostConnectionProxy
   }
 
   /**
-   * Checks if the given host index points to the primary host.
+   * Creates a new connection instance for host pointed out by the given host index.
    *
    * @param hostIndex The host index in the global hosts list.
-   * @return true if so
+   * @return The new connection instance.
+   * @throws SQLException if an error occurs
    */
-  private synchronized boolean isWriterHostIndex(int hostIndex) {
-    return hostIndex == WRITER_CONNECTION_INDEX;
+  private synchronized ConnectionImpl createConnectionForHostIndex(int hostIndex)
+      throws SQLException {
+    return createConnectionForHost(this.hosts.get(hostIndex));
+  }
+
+  /**
+   * Creates a new physical connection for the given {@link HostInfo}.
+   *
+   * @param hostInfo The host info instance.
+   * @return The new Connection instance.
+   * @throws SQLException if an error occurs
+   */
+  @Override
+  protected synchronized ConnectionImpl createConnectionForHost(HostInfo hostInfo)
+      throws SQLException {
+    ConnectionImpl conn = this.connectionProvider.connect(hostInfo);
+    setConnectionProxy(conn);
+    return conn;
+  }
+
+  protected void setConnectionProxy(JdbcConnection conn) {
+    JdbcConnection topmostProxy = getProxy();
+    if (topmostProxy != this.thisAsConnection) {
+      conn.setProxy(
+          this
+              .thisAsConnection);
+      // First call sets this connection as underlying connection parent proxy (its creator).
+    }
+    conn.setProxy(topmostProxy); // Set the topmost proxy in the underlying connection.
   }
 
   /**
@@ -755,7 +1053,7 @@ public class ClusterAwareConnectionProxy extends MultiHostConnectionProxy
    * @throws SQLException if an error occurs
    */
   private synchronized void switchCurrentConnectionTo(int hostIndex, JdbcConnection connection)
-          throws SQLException {
+      throws SQLException {
     invalidateCurrentConnection();
 
     boolean readOnly;
@@ -775,38 +1073,21 @@ public class ClusterAwareConnectionProxy extends MultiHostConnectionProxy
   }
 
   /**
-   * Creates a new connection instance for host pointed out by the given host index.
+   * Checks if the given host index points to the primary host.
    *
    * @param hostIndex The host index in the global hosts list.
-   * @return The new connection instance.
-   * @throws SQLException if an error occurs
+   * @return true if so
    */
-  private synchronized ConnectionImpl createConnectionForHostIndex(int hostIndex)
-          throws SQLException {
-    return createConnectionForHost(this.hosts.get(hostIndex));
+  private synchronized boolean isWriterHostIndex(int hostIndex) {
+    return hostIndex == WRITER_CONNECTION_INDEX;
   }
 
-  /**
-   * Creates a new physical connection for the given {@link HostInfo}.
-   *
-   * @param baseHostInfo The host info instance to base the connection off of.
-   * @return The new Connection instance.
-   * @throws SQLException if an error occurs
-   */
-  @Override
-  protected synchronized ConnectionImpl createConnectionForHost(HostInfo baseHostInfo)
-          throws SQLException {
-    HostInfo hostInfoWithInitialProps = ClusterAwareUtils.copyWithAdditionalProps(baseHostInfo, this.initialConnectionProps);
-    ConnectionImpl conn = this.connectionProvider.connect(hostInfoWithInitialProps);
-    setConnectionProxy(conn);
-    return conn;
+  protected synchronized boolean isCurrentConnectionReadOnly() {
+    return isConnected() && !isWriterHostIndex(this.currentHostIndex);
   }
 
-
-  private boolean validWriterConnection() {
-    return this.explicitlyReadOnly == null
-            || this.explicitlyReadOnly
-            || isWriterHostIndex(this.currentHostIndex);
+  protected synchronized boolean isCurrentConnectionWriter() {
+    return isWriterHostIndex(this.currentHostIndex);
   }
 
   /**
@@ -832,25 +1113,22 @@ public class ClusterAwareConnectionProxy extends MultiHostConnectionProxy
       // restarting transaction."
       this.log.logError(Messages.getString("ClusterAwareConnectionProxy.1"));
       throw new SQLException(
-              Messages.getString("ClusterAwareConnectionProxy.1"),
-              MysqlErrorNumbers.SQL_STATE_TRANSACTION_RESOLUTION_UNKNOWN);
+          Messages.getString("ClusterAwareConnectionProxy.1"),
+          MysqlErrorNumbers.SQL_STATE_TRANSACTION_RESOLUTION_UNKNOWN);
     } else {
       // "The active SQL connection has changed due to a connection failure. Please re-configure
       // session state if required."
       this.log.logError(Messages.getString("ClusterAwareConnectionProxy.3"));
       throw new SQLException(
-              Messages.getString("ClusterAwareConnectionProxy.3"),
-              MysqlErrorNumbers.SQL_STATE_COMMUNICATION_LINK_CHANGED);
+          Messages.getString("ClusterAwareConnectionProxy.3"),
+          MysqlErrorNumbers.SQL_STATE_COMMUNICATION_LINK_CHANGED);
     }
   }
 
-  private boolean shouldPerformWriterFailover() {
-    return this.explicitlyReadOnly == null || !this.explicitlyReadOnly;
-  }
-
   protected void failoverWriter() throws SQLException {
-    this.log.logDebug(Messages.getString("ClusterAwareConnectionProxy.16"));
-    WriterFailoverResult failoverResult = this.writerFailoverHandler.failover(this.hosts);
+    this.log.logDebug(Messages.getString("ClusterAwareConnectionProxy.21"));
+
+    ResolvedHostInfo failoverResult = this.writerFailoverHandler.failover(this.hosts);
 
     if (this.gatherPerfMetricsSetting) {
       long currentTimeMs = System.currentTimeMillis();
@@ -859,45 +1137,53 @@ public class ClusterAwareConnectionProxy extends MultiHostConnectionProxy
     }
 
     if (failoverResult == null || !failoverResult.isConnected()) {
+      if (this.gatherPerfMetricsSetting) {
+        this.metrics.registerFailoverConnects(false);
+      }
+
       // "Unable to establish SQL connection to writer node"
-      processFailoverFailure(Messages.getString("ClusterAwareConnectionProxy.2"));
-      return;
-    }
+      this.log.logError(Messages.getString("ClusterAwareConnectionProxy.2"));
+      throw new SQLException(
+          Messages.getString("ClusterAwareConnectionProxy.2"),
+          MysqlErrorNumbers.SQL_STATE_UNABLE_TO_CONNECT_TO_DATASOURCE);
+    } else if (failoverResult.isNewHost()) {
+      if (this.gatherPerfMetricsSetting) {
+        this.metrics.registerFailoverConnects(true);
+      }
 
-    if (failoverResult.isNewHost()) {
+      // connected to a new writer host; take it over
       this.hosts = failoverResult.getTopology();
-    }
-
-    if (this.gatherPerfMetricsSetting) {
-      this.metrics.registerFailoverConnects(true);
-    }
+      this.currentHostIndex = WRITER_CONNECTION_INDEX;
+      this.currentConnection = failoverResult.getNewConnection();
+      setConnectionProxy(this.currentConnection);
 
-    // successfully re-connected to the same writer node
-    this.currentHostIndex = WRITER_CONNECTION_INDEX;
-    this.currentConnection = failoverResult.getNewConnection();
-    setConnectionProxy(this.currentConnection);
+      this.log.logDebug(
+          Messages.getString(
+              "ClusterAwareConnectionProxy.20",
+              new Object[] {this.hosts.get(this.currentHostIndex)}));
+    } else {
+      if (this.gatherPerfMetricsSetting) {
+        this.metrics.registerFailoverConnects(true);
+      }
 
-    this.log.logDebug(
-            Messages.getString(
-                    "ClusterAwareConnectionProxy.15",
-                    new Object[] {this.hosts.get(this.currentHostIndex)}));
-  }
+      // successfully re-connected to the same writer node
+      this.currentHostIndex = WRITER_CONNECTION_INDEX;
+      this.currentConnection = failoverResult.getNewConnection();
+      setConnectionProxy(this.currentConnection);
 
-  private void processFailoverFailure(String message) throws SQLException {
-    if (this.gatherPerfMetricsSetting) {
-      this.metrics.registerFailoverConnects(false);
+      this.log.logDebug(
+          Messages.getString(
+              "ClusterAwareConnectionProxy.20",
+              new Object[] {this.hosts.get(this.currentHostIndex)}));
     }
-
-    this.log.logError(message);
-    throw new SQLException(message, MysqlErrorNumbers.SQL_STATE_UNABLE_TO_CONNECT_TO_DATASOURCE);
   }
 
   protected void failoverReader(int failedHostIdx) throws SQLException {
-    this.log.logDebug(Messages.getString("ClusterAwareConnectionProxy.17"));
+    this.log.logDebug(Messages.getString("ClusterAwareConnectionProxy.23"));
 
     HostInfo failedHost =
-            failedHostIdx == NO_CONNECTION_INDEX ? null : this.hosts.get(failedHostIdx);
-    ReaderFailoverResult result = readerFailoverHandler.failover(this.hosts, failedHost);
+        failedHostIdx == NO_CONNECTION_INDEX ? null : this.hosts.get(failedHostIdx);
+    ConnectionAttemptResult result = readerFailoverHandler.failover(this.hosts, failedHost);
 
     if (this.gatherPerfMetricsSetting) {
       long currentTimeMs = System.currentTimeMillis();
@@ -905,27 +1191,64 @@ public class ClusterAwareConnectionProxy extends MultiHostConnectionProxy
       this.failoverStartTimeMs = 0;
     }
 
-    if (result == null || !result.isConnected()) {
+    if (result == null || !result.isSuccess()) {
+      if (this.gatherPerfMetricsSetting) {
+        this.metrics.registerFailoverConnects(false);
+      }
+
       // "Unable to establish SQL connection to reader node"
-      processFailoverFailure(Messages.getString("ClusterAwareConnectionProxy.4"));
-    }
+      this.log.logError(Messages.getString("ClusterAwareConnectionProxy.4"));
+      throw new SQLException(
+          Messages.getString("ClusterAwareConnectionProxy.4"),
+          MysqlErrorNumbers.SQL_STATE_UNABLE_TO_CONNECT_TO_DATASOURCE);
+    } else {
+      if (this.gatherPerfMetricsSetting) {
+        this.metrics.registerFailoverConnects(true);
+      }
 
-    if (this.gatherPerfMetricsSetting) {
-      this.metrics.registerFailoverConnects(true);
+      this.currentConnection = result.getConnection();
+      setConnectionProxy(this.currentConnection);
+      this.currentHostIndex = result.getConnectionIndex();
+      updateTopologyAndConnectIfNeeded(true);
+      this.log.logDebug(
+          Messages.getString(
+              "ClusterAwareConnectionProxy.20",
+              new Object[] {this.hosts.get(this.currentHostIndex)}));
+      HostInfo currentHost = this.hosts.get(this.currentHostIndex);
+      if (currentHost != null) {
+        topologyService.setLastUsedReaderHost(currentHost);
+      }
     }
+  }
 
-    this.currentConnection = result.getConnection();
-    setConnectionProxy(this.currentConnection);
-    this.currentHostIndex = result.getConnectionIndex();
-    updateTopologyAndConnectIfNeeded(true);
-    this.log.logDebug(
-            Messages.getString(
-                    "ClusterAwareConnectionProxy.15",
-                    new Object[] {this.hosts.get(this.currentHostIndex)}));
-    HostInfo currentHost = this.hosts.get(this.currentHostIndex);
-    if (currentHost != null) {
-      topologyService.setLastUsedReaderHost(currentHost);
-    }
+  /**
+   * Closes current connection.
+   *
+   * @throws SQLException if an error occurs
+   */
+  @Override
+  protected synchronized void doClose() throws SQLException {
+    this.currentConnection.close();
+  }
+
+  /**
+   * Aborts current connection.
+   *
+   * @throws SQLException if an error occurs
+   */
+  @Override
+  protected synchronized void doAbortInternal() throws SQLException {
+    this.currentConnection.abortInternal();
+  }
+
+  /**
+   * Aborts current connection using the given executor.
+   *
+   * @throws SQLException if an error occurs
+   */
+  @Override
+  protected synchronized void doAbort(Executor executor) throws SQLException {
+    this.currentConnection.abort(executor);
   }
 
   protected void updateTopologyAndConnectIfNeeded(boolean forceUpdate) throws SQLException {
@@ -933,7 +1256,8 @@ public class ClusterAwareConnectionProxy extends MultiHostConnectionProxy
       return;
     }
 
-    List<HostInfo> latestTopology = this.topologyService.getTopology(this.currentConnection, forceUpdate);
+    List<HostInfo> latestTopology =
+        this.topologyService.getTopology(this.currentConnection, forceUpdate);
     if (latestTopology == null) {
       return;
     }
@@ -944,10 +1268,6 @@ public class ClusterAwareConnectionProxy extends MultiHostConnectionProxy
       return;
     }
 
-    updateHostIndex(latestTopology);
-  }
-
-  private void updateHostIndex(List<HostInfo> latestTopology) throws SQLException {
     HostInfo currentHost = this.hosts.get(this.currentHostIndex);
 
     int latestHostIndex = NO_CONNECTION_INDEX;
@@ -973,77 +1293,6 @@ public class ClusterAwareConnectionProxy extends MultiHostConnectionProxy
     }
   }
 
-  /**
-   * Checks if proxy is connected to RDS-hosted cluster.
-   *
-   * @return true if proxy is connected to RDS-hosted cluster
-   */
-  public boolean isRds() {
-    return this.isRds;
-  }
-
-  /**
-   * Checks if proxy is connected to cluster through RDS proxy.
-   *
-   * @return true if proxy is connected to cluster through RDS proxy
-   */
-  public boolean isRdsProxy() {
-    return this.isRdsProxy;
-  }
-
-  private boolean isRdsDns(String host) {
-    Matcher matcher = auroraDnsPattern.matcher(host);
-    return matcher.find();
-  }
-
-  private boolean isRdsProxyDns(String host) {
-    Matcher matcher = auroraProxyDnsPattern.matcher(host);
-    return matcher.find();
-  }
-
-  private String getRdsInstanceHostPattern(String host) {
-    Matcher matcher = auroraDnsPattern.matcher(host);
-    if (matcher.find()) {
-      return "?." + matcher.group(3);
-    }
-    return null;
-  }
-
-  private String getRdsClusterHostUrl(String host) {
-    Matcher matcher = auroraDnsPattern.matcher(host);
-    String clusterKeyword = getClusterKeyword(matcher);
-    if ("cluster-".equalsIgnoreCase(clusterKeyword)
-            || "cluster-ro-".equalsIgnoreCase(clusterKeyword)) {
-      return matcher.group(1) + ".cluster-" + matcher.group(3); // always RDS cluster endpoint
-    }
-    return null;
-  }
-  private boolean isRdsClusterDns(String host) {
-    Matcher matcher = auroraDnsPattern.matcher(host);
-    String clusterKeyword = getClusterKeyword(matcher);
-    return "cluster-".equalsIgnoreCase(clusterKeyword)
-            || "cluster-ro-".equalsIgnoreCase(clusterKeyword);
-  }
-
-  private boolean isReaderClusterDns(String host) {
-    Matcher matcher = auroraDnsPattern.matcher(host);
-    return "cluster-ro-".equalsIgnoreCase(getClusterKeyword(matcher));
-  }
-  private boolean isRdsCustomClusterDns(String host) {
-    Matcher matcher = auroraCustomClusterPattern.matcher(host);
-    return matcher.find();
-  }
-
-  private String getClusterKeyword(Matcher matcher) {
-    if (matcher.find()
-            && matcher.group(2) != null
-            && matcher.group(1) != null
-            && !matcher.group(1).isEmpty()) {
-      return matcher.group(2);
-    }
-    return null;
-  }
-
   @Override
   public synchronized Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
     this.invokeStartTimeMs = this.gatherPerfMetricsSetting ? System.currentTimeMillis() : 0;
@@ -1062,19 +1311,36 @@ public class ClusterAwareConnectionProxy extends MultiHostConnectionProxy
     return result;
   }
 
-  /**
+  /*
    * Local method invocation handling for this proxy.
    * This is the continuation of MultiHostConnectionProxy#invoke(Object, Method, Object[]).
    */
   @Override
   public synchronized Object invokeMore(Object proxy, Method method, Object[] args)
-          throws Throwable {
+      throws Throwable {
     final String methodName = method.getName();
 
     updateTopologyAndConnectIfNeeded(false);
 
     if (this.isClosed && !allowedOnClosedConnection(method)) {
-      invalidInvocationOnClosedConnection();
+      if (this.autoReconnect && !this.closedExplicitly) {
+        this.currentHostIndex = NO_CONNECTION_INDEX; // Act as if this is the first connection but let it sync with the previous one.
+        this.isClosed = false;
+        this.closedReason = null;
+        pickNewConnection();
+
+        // "The active SQL connection has changed. Please re-configure session state if required."
+        this.log.logError(Messages.getString("ClusterAwareConnectionProxy.25"));
+        throw new SQLException(
+                Messages.getString("ClusterAwareConnectionProxy.25"),
+                MysqlErrorNumbers.SQL_STATE_COMMUNICATION_LINK_CHANGED);
+      } else {
+        String reason = "No operations allowed after connection closed.";
+        if (this.closedReason != null) {
+          reason += ("  " + this.closedReason);
+        }
+        throw SQLError.createSQLException(reason, MysqlErrorNumbers.SQL_STATE_CONNECTION_NOT_OPEN, null /* no access to a interceptor here... */);
+      }
     }
 
     Object result = null;
@@ -1087,120 +1353,6 @@ public class ClusterAwareConnectionProxy extends MultiHostConnectionProxy
       dealWithIllegalStateException(e);
     }
 
-    performExtraActionsIfRequired(args, methodName);
-    return result;
-  }
-
-  private void invalidInvocationOnClosedConnection() throws SQLException {
-    if (this.autoReconnect && !this.closedExplicitly) {
-      this.currentHostIndex = NO_CONNECTION_INDEX; // Act as if this is the first connection but let it sync with the previous one.
-      this.isClosed = false;
-      this.closedReason = null;
-      pickNewConnection();
-
-      // "The active SQL connection has changed. Please re-configure session state if required."
-      this.log.logError(Messages.getString("ClusterAwareConnectionProxy.19"));
-      throw new SQLException(
-              Messages.getString("ClusterAwareConnectionProxy.19"),
-              MysqlErrorNumbers.SQL_STATE_COMMUNICATION_LINK_CHANGED);
-    } else {
-      String reason = "No operations allowed after connection closed.";
-      if (this.closedReason != null) {
-        reason += ("  " + this.closedReason);
-      }
-      throw SQLError.createSQLException(reason, MysqlErrorNumbers.SQL_STATE_CONNECTION_NOT_OPEN, null /* no access to a interceptor here... */);
-    }
-  }
-
-  /**
-   * Deals with InvocationException from proxied objects.
-   *
-   * @param e The Exception instance to check.
-   * @throws SQLException if an error occurs
-   * @throws Throwable if an error occurs
-   * @throws InvocationTargetException if an error occurs
-   */
-  @Override
-  protected synchronized void dealWithInvocationException(InvocationTargetException e)
-          throws SQLException, Throwable, InvocationTargetException {
-    dealWithOriginalException(e.getTargetException(), e);
-  }
-
-  protected void dealWithIllegalStateException(IllegalStateException e) throws Throwable {
-    dealWithOriginalException(e.getCause(), e);
-  }
-
-  private void dealWithOriginalException(Throwable originalException, Exception wrapperException) throws Throwable {
-    if (originalException != null) {
-      this.log.logTrace(Messages.getString("ClusterAwareConnectionProxy.12"), originalException);
-      if (this.lastExceptionDealtWith != originalException && shouldExceptionTriggerConnectionSwitch(originalException)) {
-        if (this.gatherPerfMetricsSetting) {
-          long currentTimeMs = System.currentTimeMillis();
-          this.metrics.registerFailureDetectionTime(currentTimeMs - this.invokeStartTimeMs);
-          this.invokeStartTimeMs = 0;
-          this.failoverStartTimeMs = currentTimeMs;
-        }
-        invalidateCurrentConnection();
-        pickNewConnection();
-        this.lastExceptionDealtWith = originalException;
-      }
-      throw originalException;
-    }
-    throw wrapperException;
-  }
-
-  /**
-   * Local implementation for the connection switch exception checker.
-   */
-  @Override
-  protected boolean shouldExceptionTriggerConnectionSwitch(Throwable t) {
-
-    if (!isFailoverEnabled()) {
-      this.log.logDebug(Messages.getString("ClusterAwareConnectionProxy.13"));
-      return false;
-    }
-
-    String sqlState = null;
-    if (t instanceof CommunicationsException || t instanceof CJCommunicationsException) {
-      return true;
-    } else if (t instanceof SQLException) {
-      sqlState = ((SQLException) t).getSQLState();
-    } else if (t instanceof CJException) {
-      if (t.getCause() instanceof EOFException) { // Can not read response from server
-        return true;
-      }
-      if (t.getCause() instanceof SSLException) { // Incomplete packets from server may cause SSL communication issues
-        return true;
-      }
-      sqlState = ((CJException) t).getSQLState();
-    }
-
-    if (sqlState != null) {
-      // connection error
-      return sqlState.startsWith("08");
-    }
-
-    return false;
-  }
-
-  /**
-   * Invalidates the current connection.
-   *
-   * @throws SQLException if an error occurs
-   */
-  @Override
-  protected synchronized void invalidateCurrentConnection() throws SQLException {
-    if (this.inTransaction) {
-      try {
-        this.currentConnection.rollback();
-      } catch (SQLException e) {
-        // eat
-      }
-    }
-    super.invalidateConnection(this.currentConnection);
-  }
-
-  private void performExtraActionsIfRequired(Object[] args, String methodName) throws SQLException {
     if (METHOD_SET_AUTO_COMMIT.equals(methodName)) {
       this.explicitlyAutoCommit = (Boolean) args[0];
       this.inTransaction = !this.explicitlyAutoCommit;
@@ -1213,11 +1365,13 @@ public class ClusterAwareConnectionProxy extends MultiHostConnectionProxy
     if (METHOD_SET_READ_ONLY.equals(methodName)) {
       this.explicitlyReadOnly = (Boolean) args[0];
       this.log.logTrace(
-              Messages.getString(
-                      "ClusterAwareConnectionProxy.10",
-                      new Object[] {"explicitlyReadOnly", this.explicitlyReadOnly}));
+          Messages.getString(
+              "ClusterAwareConnectionProxy.12",
+              new Object[] {"explicitlyReadOnly", this.explicitlyReadOnly}));
       connectToWriterIfRequired(this.explicitlyReadOnly);
     }
+
+    return result;
   }
 
   private void connectToWriterIfRequired(Boolean readOnly) throws SQLException {
@@ -1235,92 +1389,12 @@ public class ClusterAwareConnectionProxy extends MultiHostConnectionProxy
     }
   }
 
-  /**
-   * Closes current connection.
-   *
-   * @throws SQLException if an error occurs
-   */
-  @Override
-  protected synchronized void doClose() throws SQLException {
-    this.currentConnection.close();
-  }
-
-  /**
-   * Aborts current connection using the given executor.
-   *
-   * @throws SQLException if an error occurs
-   */
-  @Override
-  protected synchronized void doAbort(Executor executor) throws SQLException {
-    this.currentConnection.abort(executor);
-  }
-
-  /**
-   * Aborts current connection.
-   *
-   * @throws SQLException if an error occurs
-   */
-  @Override
-  protected synchronized void doAbortInternal() throws SQLException {
-    this.currentConnection.abortInternal();
-  }
-
-  @Override
-  protected InvocationHandler getNewJdbcInterfaceProxy(Object toProxy) {
-    return new JdbcInterfaceProxy(toProxy);
-  }
-
-  /** Checks if current connection is to a master (writer) host. */
-  @Override
-  protected boolean isSourceConnection() {
-    return isWriterHostIndex(this.currentHostIndex);
-  }
-
   @Override
   public ConnectionLifecycleInterceptor getConnectionLifecycleInterceptor() {
     return new ClusterAwareConnectionLifecycleInterceptor(this);
   }
 
-  protected synchronized boolean isCurrentConnectionReadOnly() {
-    return isConnected() && !isWriterHostIndex(this.currentHostIndex);
-  }
-
-  protected synchronized boolean isCurrentConnectionWriter() {
-    return isWriterHostIndex(this.currentHostIndex);
-  }
-
   protected JdbcConnection getConnection() {
     return this.currentConnection;
   }
-
-  /**
-   * Checks if proxy is connected to cluster that can report its topology.
-   *
-   * @return true if proxy is connected to cluster that can report its topology
-   */
-  public boolean isClusterTopologyAvailable() {
-    return this.isClusterTopologyAvailable;
-  }
-
-  /**
-   * Checks if proxy is connected to multi-writer cluster.
-   *
-   * @return true if proxy is connected to multi-writer cluster
-   */
-  public boolean isMultiWriterCluster() {
-    return this.isMultiWriterCluster;
-  }
-
-  private void logTopology() {
-    StringBuilder msg = new StringBuilder();
-    for (int i = 0; i < this.hosts.size(); i++) {
-      HostInfo hostInfo = this.hosts.get(i);
-      msg.append("\n   [")
-              .append(i)
-              .append("]: ")
-              .append(hostInfo == null ? "<null>" : hostInfo.getHost());
-    }
-    this.log.logTrace(
-        Messages.getString("ClusterAwareConnectionProxy.11", new Object[] {msg.toString()}));
-  }
 }
diff --git a/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareHitMissMetricsHolder.java b/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareHitMissMetricsHolder.java
index 082c060..b05c51c 100644
--- a/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareHitMissMetricsHolder.java
+++ b/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareHitMissMetricsHolder.java
@@ -44,7 +44,7 @@ public class ClusterAwareHitMissMetricsHolder {
   protected int numberOfReports;
   protected int numberOfHits;
 
-  private final Object lockObject = new Object();
+  private Object lockObject = new Object();
 
   /**
    * Initialize a metric holder with a metric name.
@@ -80,10 +80,10 @@ public class ClusterAwareHitMissMetricsHolder {
     logMessage.append("** Performance Metrics Report for '");
     logMessage.append(this.metricName);
     logMessage.append("' **\n");
-    logMessage.append("\nNumber of reports: ").append(this.numberOfReports);
+    logMessage.append("\nNumber of reports: " + this.numberOfReports);
     if (this.numberOfReports > 0) {
-      logMessage.append("\nNumber of hits: ").append(this.numberOfHits);
-      logMessage.append("\nRatio : ").append(this.numberOfHits * 100.0 / this.numberOfReports).append(" %");
+      logMessage.append("\nNumber of hits: " + this.numberOfHits);
+      logMessage.append("\nRatio : " + (this.numberOfHits * 100.0 / this.numberOfReports) + " %");
     }
 
     log.logInfo(logMessage);
diff --git a/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareMetrics.java b/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareMetrics.java
index 504c82a..12e7f76 100644
--- a/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareMetrics.java
+++ b/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareMetrics.java
@@ -55,19 +55,19 @@ import com.mysql.cj.log.Log;
  */
 public class ClusterAwareMetrics {
 
-  private final ClusterAwareTimeMetricsHolder failureDetection =
+  private ClusterAwareTimeMetricsHolder failureDetection =
       new ClusterAwareTimeMetricsHolder("Failover Detection");
-  private final ClusterAwareTimeMetricsHolder writerFailoverProcedure =
+  private ClusterAwareTimeMetricsHolder writerFailoverProcedure =
       new ClusterAwareTimeMetricsHolder("Writer Failover Procedure");
-  private final ClusterAwareTimeMetricsHolder readerFailoverProcedure =
+  private ClusterAwareTimeMetricsHolder readerFailoverProcedure =
       new ClusterAwareTimeMetricsHolder("Reader Failover Procedure");
-  private final ClusterAwareHitMissMetricsHolder failoverConnects =
+  private ClusterAwareHitMissMetricsHolder failoverConnects =
       new ClusterAwareHitMissMetricsHolder("Successful Failover Reconnects");
-  private final ClusterAwareHitMissMetricsHolder invalidInitialConnection =
+  private ClusterAwareHitMissMetricsHolder invalidInitialConnection =
       new ClusterAwareHitMissMetricsHolder("Invalid Initial Connection");
-  private final ClusterAwareHitMissMetricsHolder useLastConnectedReader =
+  private ClusterAwareHitMissMetricsHolder useLastConnectedReader =
       new ClusterAwareHitMissMetricsHolder("Used Last Connected Reader");
-  private final ClusterAwareHitMissMetricsHolder useCachedTopology =
+  private ClusterAwareHitMissMetricsHolder useCachedTopology =
       new ClusterAwareHitMissMetricsHolder("Used Cached Topology");
 
   public ClusterAwareMetrics() {}
diff --git a/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareReaderFailoverHandler.java b/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareReaderFailoverHandler.java
index 7281fe5..367d87e 100644
--- a/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareReaderFailoverHandler.java
+++ b/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareReaderFailoverHandler.java
@@ -40,7 +40,6 @@ import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
-import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CompletionService;
@@ -71,15 +70,15 @@ public class ClusterAwareReaderFailoverHandler implements ReaderFailoverHandler
 
   /** The logger we're going to use. */
   protected transient Log log = NULL_LOGGER;
-  protected Map<String, String> initialConnectionProps;
+
   protected int maxFailoverTimeoutMs;
   protected int timeoutMs;
   protected final ConnectionProvider connProvider;
   protected final TopologyService topologyService;
 
   public ClusterAwareReaderFailoverHandler(
-          TopologyService topologyService, ConnectionProvider connProvider, Map<String, String> initialConnectionProps, Log log) {
-    this(topologyService, connProvider, initialConnectionProps, DEFAULT_FAILOVER_TIMEOUT, DEFAULT_READER_CONNECT_TIMEOUT, log);
+      TopologyService topologyService, ConnectionProvider connProvider, Log log) {
+    this(topologyService, connProvider, DEFAULT_FAILOVER_TIMEOUT, DEFAULT_READER_CONNECT_TIMEOUT, log);
   }
 
 
@@ -87,10 +86,9 @@ public class ClusterAwareReaderFailoverHandler implements ReaderFailoverHandler
    * ClusterAwareReaderFailoverHandler constructor.
    * */
   public ClusterAwareReaderFailoverHandler(
-      TopologyService topologyService, ConnectionProvider connProvider, Map<String, String> initialConnectionProps, int failoverTimeoutMs, int timeoutMs, Log log) {
+      TopologyService topologyService, ConnectionProvider connProvider, int failoverTimeoutMs, int timeoutMs, Log log) {
     this.topologyService = topologyService;
     this.connProvider = connProvider;
-    this.initialConnectionProps = initialConnectionProps;
     this.maxFailoverTimeoutMs = failoverTimeoutMs;
     this.timeoutMs = timeoutMs;
 
@@ -116,35 +114,30 @@ public class ClusterAwareReaderFailoverHandler implements ReaderFailoverHandler
    *
    * @param hosts Cluster current topology
    * @param currentHost The currently connected host that has failed.
-   * @return {@link ReaderFailoverResult} The results of this process.
+   * @return {@link ConnectionAttemptResult} The results of this process. May return null, which is
+   *     considered an unsuccessful result.
    */
   @Override
-  public ReaderFailoverResult failover(List<HostInfo> hosts, HostInfo currentHost)
+  public ConnectionAttemptResult failover(List<HostInfo> hosts, HostInfo currentHost)
       throws SQLException {
-    ExecutorService executor = Executors.newSingleThreadExecutor();
-    Future<ReaderFailoverResult> future = submitInternalFailoverTask(hosts, currentHost, executor);
-    return getInternalFailoverResult(executor, future);
-  }
 
-  private Future<ReaderFailoverResult> submitInternalFailoverTask(List<HostInfo> hosts, HostInfo currentHost, ExecutorService executor) {
-    Future<ReaderFailoverResult> future = executor.submit(() -> {
-      ReaderFailoverResult result = null;
-      while(result == null || !result.isConnected()) {
+    ExecutorService executor = Executors.newSingleThreadExecutor();
+    Future<ConnectionAttemptResult> future = executor.submit(() -> {
+      ConnectionAttemptResult result = null;
+      while(result == null) {
         result = failoverInternal(hosts, currentHost);
-        TimeUnit.SECONDS.sleep(1);
+        TimeUnit.MILLISECONDS.sleep(1);
       }
       return result;
     });
     executor.shutdown();
-    return future;
-  }
 
-  private ReaderFailoverResult getInternalFailoverResult(ExecutorService executor, Future<ReaderFailoverResult> future) throws SQLException {
-    ReaderFailoverResult defaultResult = new ReaderFailoverResult(
+    ConnectionAttemptResult defaultResult = new ConnectionAttemptResult(
             null, ClusterAwareConnectionProxy.NO_CONNECTION_INDEX, false);
+
+
     try {
-      ReaderFailoverResult result = future.get(this.maxFailoverTimeoutMs, TimeUnit.MILLISECONDS);
-      return result == null ? defaultResult : result;
+      return future.get(this.maxFailoverTimeoutMs, TimeUnit.MILLISECONDS);
 
     } catch (InterruptedException e) {
       Thread.currentThread().interrupt();
@@ -165,11 +158,12 @@ public class ClusterAwareReaderFailoverHandler implements ReaderFailoverHandler
     }
   }
 
-  protected ReaderFailoverResult failoverInternal(List<HostInfo> hosts, HostInfo currentHost)
+  protected ConnectionAttemptResult failoverInternal(List<HostInfo> hosts, HostInfo currentHost)
           throws SQLException {
     this.topologyService.addToDownHostList(currentHost);
     if (hosts == null || hosts.isEmpty()) {
-      return new ReaderFailoverResult(null, ClusterAwareConnectionProxy.NO_CONNECTION_INDEX, false);
+      return new ConnectionAttemptResult(
+              null, ClusterAwareConnectionProxy.NO_CONNECTION_INDEX, false);
     }
     Set<String> downHosts = topologyService.getDownHosts();
     List<HostTuple> hostGroup = getHostTuplesByPriority(hosts, downHosts);
@@ -219,10 +213,11 @@ public class ClusterAwareReaderFailoverHandler implements ReaderFailoverHandler
    * is unsuccessful. This process will not attempt to connect to the writer.
    *
    * @param hostList Cluster current topology
-   * @return {@link ReaderFailoverResult} The results of this process.
+   * @return {@link ConnectionAttemptResult} The results of this process. May return null, which is
+   *     considered an unsuccessful result.
    */
   @Override
-  public ReaderFailoverResult getReaderConnection(List<HostInfo> hostList) throws SQLException {
+  public ConnectionAttemptResult getReaderConnection(List<HostInfo> hostList) throws SQLException {
     Set<String> downHosts = topologyService.getDownHosts();
     List<HostTuple> tuples = getReaderTuplesByPriority(hostList, downHosts);
     return getConnectionFromHostGroup(tuples);
@@ -247,17 +242,35 @@ public class ClusterAwareReaderFailoverHandler implements ReaderFailoverHandler
     list.addAll(downReaders);
   }
 
-  private ReaderFailoverResult getConnectionFromHostGroup(List<HostTuple> hostGroup)
+  private ConnectionAttemptResult getConnectionFromHostGroup(List<HostTuple> hostGroup)
       throws SQLException {
     ExecutorService executor = Executors.newFixedThreadPool(2);
-    CompletionService<ReaderFailoverResult> completionService =
+    CompletionService<ConnectionAttemptResult> completionService =
         new ExecutorCompletionService<>(executor);
 
+    ConnectionAttemptResult result;
+
     try {
       for (int i = 0; i < hostGroup.size(); i += 2) {
-        // submit connection attempt tasks in batches of 2
-        ReaderFailoverResult result = getResultFromNextTaskBatch(hostGroup, executor, completionService, i);
-        if (result.isConnected()) {
+        boolean secondAttemptPresent = i + 1 < hostGroup.size();
+        Future<ConnectionAttemptResult> attempt1 =
+                completionService.submit(
+                        new ConnectionAttemptTask(
+                                this.connProvider, hostGroup.get(i), this.topologyService, this.log));
+        if (secondAttemptPresent) {
+          Future<ConnectionAttemptResult> attempt2 =
+                  completionService.submit(
+                          new ConnectionAttemptTask(
+                                  this.connProvider, hostGroup.get(i + 1), this.topologyService, this.log));
+          result = getResultFromAttemptPair(attempt1, attempt2, completionService);
+        } else {
+          result = getNextResult(completionService);
+        }
+
+        if (result.isSuccess()) {
+          this.log.logDebug(
+                  Messages.getString(
+                          "ClusterAwareReaderFailoverHandler.2", new Object[]{result.getConnectionIndex()}));
           return result;
         }
 
@@ -270,45 +283,55 @@ public class ClusterAwareReaderFailoverHandler implements ReaderFailoverHandler
         }
       }
 
-      return new ReaderFailoverResult(null, ClusterAwareConnectionProxy.NO_CONNECTION_INDEX, false);
+      return new ConnectionAttemptResult(
+              null, ClusterAwareConnectionProxy.NO_CONNECTION_INDEX, false);
+
     } finally {
       executor.shutdownNow();
     }
   }
 
-  private ReaderFailoverResult getResultFromNextTaskBatch(List<HostTuple> hostGroup, ExecutorService executor, CompletionService<ReaderFailoverResult> completionService, int i) throws SQLException {
-    ReaderFailoverResult result;
-    int numTasks = i + 1 < hostGroup.size() ? 2 : 1;
-    completionService.submit(new ConnectionAttemptTask(hostGroup.get(i)));
-    if (numTasks == 2) {
-      completionService.submit(new ConnectionAttemptTask(hostGroup.get(i + 1)));
-    }
-    for(int taskNum = 0; taskNum < numTasks; taskNum++) {
-      result = getNextResult(completionService);
-      if (result.isConnected()) {
-        executor.shutdownNow();
-        this.log.logDebug(
-                Messages.getString(
-                        "ClusterAwareReaderFailoverHandler.2", new Object[]{result.getConnectionIndex()}));
-        return result;
+  private ConnectionAttemptResult getResultFromAttemptPair(
+      Future<ConnectionAttemptResult> attempt1,
+      Future<ConnectionAttemptResult> attempt2,
+      CompletionService<ConnectionAttemptResult> service)
+      throws SQLException {
+    try {
+      Future<ConnectionAttemptResult> firstCompleted =
+          service.poll(this.timeoutMs, TimeUnit.MILLISECONDS);
+      if (firstCompleted != null) {
+        ConnectionAttemptResult result = firstCompleted.get();
+        if (result.isSuccess()) {
+          if (firstCompleted.equals(attempt1)) {
+            attempt2.cancel(true);
+          } else {
+            attempt1.cancel(true);
+          }
+          return result;
+        }
       }
+    } catch (ExecutionException e) {
+      return getNextResult(service);
+    } catch (InterruptedException e) {
+      Thread.currentThread().interrupt();
+      // "Thread was interrupted"
+      throw new SQLException(Messages.getString("ClusterAwareReaderFailoverHandler.1"), "70100", e);
     }
-    return new ReaderFailoverResult(null, ClusterAwareConnectionProxy.NO_CONNECTION_INDEX, false);
+    return getNextResult(service);
   }
 
-  private ReaderFailoverResult getNextResult(CompletionService<ReaderFailoverResult> service)
+  private ConnectionAttemptResult getNextResult(CompletionService<ConnectionAttemptResult> service)
       throws SQLException {
-    ReaderFailoverResult defaultResult = new ReaderFailoverResult(
-            null, ClusterAwareConnectionProxy.NO_CONNECTION_INDEX, false);
     try {
-      Future<ReaderFailoverResult> future = service.poll(this.timeoutMs, TimeUnit.MILLISECONDS);
-      if (future == null) {
-        return defaultResult;
+      Future<ConnectionAttemptResult> result = service.poll(this.timeoutMs, TimeUnit.MILLISECONDS);
+      if (result == null) {
+        return new ConnectionAttemptResult(
+            null, ClusterAwareConnectionProxy.NO_CONNECTION_INDEX, false);
       }
-      ReaderFailoverResult result = future.get();
-      return result == null ? defaultResult : result;
+      return result.get();
     } catch (ExecutionException e) {
-      return defaultResult;
+      return new ConnectionAttemptResult(
+          null, ClusterAwareConnectionProxy.NO_CONNECTION_INDEX, false);
     } catch (InterruptedException e) {
       Thread.currentThread().interrupt();
       // "Thread was interrupted"
@@ -316,40 +339,50 @@ public class ClusterAwareReaderFailoverHandler implements ReaderFailoverHandler
     }
   }
 
-  private class ConnectionAttemptTask implements Callable<ReaderFailoverResult> {
+  private static class ConnectionAttemptTask implements Callable<ConnectionAttemptResult> {
+    private final ConnectionProvider connProvider;
     private final HostTuple newHostTuple;
-
-    private ConnectionAttemptTask(HostTuple newHostTuple) {
+    private final TopologyService topologyService;
+    private final transient Log log;
+
+    private ConnectionAttemptTask(
+        ConnectionProvider connProvider,
+        HostTuple newHostTuple,
+        TopologyService topologyService,
+        Log log) {
+      this.connProvider = connProvider;
       this.newHostTuple = newHostTuple;
+      this.topologyService = topologyService;
+      this.log = log;
     }
 
     /**
      * Call ConnectionAttemptResult.
      * */
     @Override
-    public ReaderFailoverResult call() {
+    public ConnectionAttemptResult call() {
       HostInfo newHost = this.newHostTuple.getHost();
-      log.logDebug(
+      this.log.logDebug(
           Messages.getString(
               "ClusterAwareReaderFailoverHandler.3",
               new Object[] {this.newHostTuple.getIndex(), newHost.getHostPortPair()}));
 
       try {
-        HostInfo newHostWithProps = ClusterAwareUtils.copyWithAdditionalProps(newHost, initialConnectionProps);
-        JdbcConnection conn = connProvider.connect(newHostWithProps);
+        JdbcConnection conn = this.connProvider.connect(newHost);
         topologyService.removeFromDownHostList(newHost);
-        log.logDebug(
+        this.log.logDebug(
             Messages.getString(
                 "ClusterAwareReaderFailoverHandler.4",
                 new Object[] {this.newHostTuple.getIndex(), newHost.getHostPortPair()}));
-        return new ReaderFailoverResult(conn, this.newHostTuple.getIndex(), true);
+        return new ConnectionAttemptResult(conn, this.newHostTuple.getIndex(), true);
       } catch (SQLException e) {
         topologyService.addToDownHostList(newHost);
-        log.logDebug(
+        this.log.logDebug(
             Messages.getString(
                 "ClusterAwareReaderFailoverHandler.5",
                 new Object[] {this.newHostTuple.getIndex(), newHost.getHostPortPair()}));
-        return new ReaderFailoverResult(null, ClusterAwareConnectionProxy.NO_CONNECTION_INDEX, false);
+        return new ConnectionAttemptResult(
+            null, ClusterAwareConnectionProxy.NO_CONNECTION_INDEX, false);
       }
     }
   }
diff --git a/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareTimeMetricsHolder.java b/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareTimeMetricsHolder.java
index 7ed190f..766f278 100644
--- a/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareTimeMetricsHolder.java
+++ b/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareTimeMetricsHolder.java
@@ -62,14 +62,18 @@ public class ClusterAwareTimeMetricsHolder extends BaseMetricsHolder {
   public void reportMetrics(Log log) {
     StringBuilder logMessage = new StringBuilder(256);
 
-    logMessage.append("** Performance Metrics Report for '").append(this.metricName).append("' **\n");
+    logMessage.append("** Performance Metrics Report for '");
+    logMessage.append(this.metricName);
+    logMessage.append("' **\n");
     if (this.numberOfQueriesIssued > 0) {
-      logMessage.append("\nLongest reported time: ").append(this.longestQueryTimeMs).append(" ms");
-      logMessage.append("\nShortest reported time: ").append(this.shortestQueryTimeMs).append(" ms");
-      double avgTime = this.totalQueryTimeMs / this.numberOfQueriesIssued;
-      logMessage.append("\nAverage query execution time: ").append(avgTime).append(" ms");
+      logMessage.append("\nLongest reported time: " + this.longestQueryTimeMs + " ms");
+      logMessage.append("\nShortest reported time: " + this.shortestQueryTimeMs + " ms");
+      logMessage.append(
+          "\nAverage query execution time: "
+              + (this.totalQueryTimeMs / this.numberOfQueriesIssued)
+              + " ms");
     }
-    logMessage.append("\nNumber of reports: ").append(this.numberOfQueriesIssued);
+    logMessage.append("\nNumber of reports: " + this.numberOfQueriesIssued);
 
     if (this.numberOfQueriesIssued > 0 && this.perfMetricsHistBreakpoints != null) {
       logMessage.append("\n\n\tTiming Histogram:\n");
@@ -89,17 +93,19 @@ public class ClusterAwareTimeMetricsHolder extends BaseMetricsHolder {
       for (int i = 0; i < (HISTOGRAM_BUCKETS - 1); i++) {
 
         if (i == 0) {
-          logMessage.append("\n\tless than ")
-                  .append(this.perfMetricsHistBreakpoints[i + 1])
-                  .append(" ms: \t")
-                  .append(this.perfMetricsHistCounts[i]);
+          logMessage.append(
+              "\n\tless than "
+                  + this.perfMetricsHistBreakpoints[i + 1]
+                  + " ms: \t"
+                  + this.perfMetricsHistCounts[i]);
         } else {
-          logMessage.append("\n\tbetween ")
-                  .append(this.perfMetricsHistBreakpoints[i])
-                  .append(" and ")
-                  .append(this.perfMetricsHistBreakpoints[i + 1])
-                  .append(" ms: \t")
-                  .append(this.perfMetricsHistCounts[i]);
+          logMessage.append(
+              "\n\tbetween "
+                  + this.perfMetricsHistBreakpoints[i]
+                  + " and "
+                  + this.perfMetricsHistBreakpoints[i + 1]
+                  + " ms: \t"
+                  + this.perfMetricsHistCounts[i]);
         }
 
         logMessage.append("\t");
diff --git a/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareUtils.java b/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareUtils.java
deleted file mode 100644
index 6c9e88a..0000000
--- a/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareUtils.java
+++ /dev/null
@@ -1,30 +0,0 @@
-package com.mysql.cj.jdbc.ha.ca;
-
-import com.mysql.cj.conf.ConnectionUrl;
-import com.mysql.cj.conf.DatabaseUrlContainer;
-import com.mysql.cj.conf.HostInfo;
-
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Properties;
-
-public class ClusterAwareUtils {
-    /**
-     * Create a copy of the given {@link HostInfo} object where all details are the same except for the host properties,
-     * which will contain both the original properties and the properties passed into the function
-     *
-     * @param baseHostInfo The {@link HostInfo} object to copy
-     * @param additionalProps The map of properties to add to the new {@link HostInfo} copy
-     *
-     * @return A copy of the given {@link HostInfo} object where all details are the same except for the host properties,
-     *      will contain both the original properties and the properties passed into the function
-     */
-    public static HostInfo copyWithAdditionalProps(HostInfo baseHostInfo, Map<String, String> additionalProps) {
-        DatabaseUrlContainer urlContainer = ConnectionUrl.getConnectionUrlInstance(baseHostInfo.getDatabaseUrl(), new Properties());
-        Map<String, String> originalProps = baseHostInfo.getHostProperties();
-        Map<String, String> mergedProps = new HashMap<>();
-        mergedProps.putAll(originalProps);
-        mergedProps.putAll(additionalProps);
-        return new HostInfo(urlContainer, baseHostInfo.getHost(), baseHostInfo.getPort(), baseHostInfo.getUser(), baseHostInfo.getPassword(), mergedProps);
-    }
-}
diff --git a/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareWriterFailoverHandler.java b/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareWriterFailoverHandler.java
index 668b5d3..a9577c6 100644
--- a/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareWriterFailoverHandler.java
+++ b/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareWriterFailoverHandler.java
@@ -37,17 +37,14 @@ import com.mysql.cj.log.Log;
 import com.mysql.cj.log.NullLogger;
 
 import java.sql.SQLException;
-import java.util.ArrayList;
 import java.util.List;
-import java.util.Map;
-import java.util.concurrent.Callable;
-import java.util.concurrent.CompletionService;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ExecutorCompletionService;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.Executors;
 
 /**
  * An implementation of WriterFailoverHandler.
@@ -70,7 +67,6 @@ public class ClusterAwareWriterFailoverHandler implements WriterFailoverHandler
   protected int maxFailoverTimeoutMs = 60000; // 60 sec
   protected int readTopologyIntervalMs = 5000; // 5 sec
   protected int reconnectWriterIntervalMs = 5000; // 5 sec
-  protected Map<String, String> initialConnectionProps;
   protected TopologyService topologyService;
   protected ConnectionProvider connectionProvider;
   protected ReaderFailoverHandler readerFailoverHandler;
@@ -82,12 +78,10 @@ public class ClusterAwareWriterFailoverHandler implements WriterFailoverHandler
       TopologyService topologyService,
       ConnectionProvider connectionProvider,
       ReaderFailoverHandler readerFailoverHandler,
-      Map<String, String> initialConnectionProps,
       Log log) {
     this.topologyService = topologyService;
     this.connectionProvider = connectionProvider;
     this.readerFailoverHandler = readerFailoverHandler;
-    this.initialConnectionProps = initialConnectionProps;
 
     if (log != null) {
       this.log = log;
@@ -101,12 +95,11 @@ public class ClusterAwareWriterFailoverHandler implements WriterFailoverHandler
       TopologyService topologyService,
       ConnectionProvider connectionProvider,
       ReaderFailoverHandler readerFailoverHandler,
-      Map<String, String> initialConnectionProps,
       int failoverTimeoutMs,
       int readTopologyIntervalMs,
       int reconnectWriterIntervalMs,
       Log log) {
-    this(topologyService, connectionProvider, readerFailoverHandler, initialConnectionProps, log);
+    this(topologyService, connectionProvider, readerFailoverHandler, log);
     this.maxFailoverTimeoutMs = failoverTimeoutMs;
     this.readTopologyIntervalMs = readTopologyIntervalMs;
     this.reconnectWriterIntervalMs = reconnectWriterIntervalMs;
@@ -116,88 +109,179 @@ public class ClusterAwareWriterFailoverHandler implements WriterFailoverHandler
    * Called to start Writer Failover Process.
    *
    * @param currentTopology Cluster current topology
-   * @return {@link WriterFailoverResult} The results of this process. May return null, which is
+   * @return {@link ResolvedHostInfo} The results of this process. May return null, which is
    *     considered an unsuccessful result.
    */
   @Override
-  public WriterFailoverResult failover(List<HostInfo> currentTopology) throws SQLException {
-    if(currentTopology == null) {
-      this.log.logError(Messages.getString("ClusterAwareWriterFailoverHandler.7"));
-      return new WriterFailoverResult(false, false, null, null);
-    }
-    ExecutorService executorService = Executors.newFixedThreadPool(2);
-    CompletionService<WriterFailoverResult> completionService =
-            new ExecutorCompletionService<>(executorService);
+  public ResolvedHostInfo failover(List<HostInfo> currentTopology) throws SQLException {
+
+    ExecutorService executorService = null;
     try {
-      for(int numTasks = submitTasks(currentTopology, executorService, completionService); numTasks > 0; numTasks--) {
-        WriterFailoverResult result = getNextResult(executorService, completionService);
-        if(result.isConnected()) return result;
+      executorService = Executors.newFixedThreadPool(2);
+
+      CountDownLatch taskCompletedLatch = new CountDownLatch(1);
+
+      ReconnectToWriterHandler taskA = null;
+      Future<?> futureA = null;
+
+      HostInfo writerHost = currentTopology.get(WRITER_CONNECTION_INDEX);
+      this.topologyService.addToDownHostList(writerHost);
+      if (writerHost != null) {
+        taskA = new ReconnectToWriterHandler(
+                taskCompletedLatch,
+                writerHost,
+                this.topologyService,
+                this.connectionProvider,
+                this.reconnectWriterIntervalMs,
+                this.log);
+        futureA = executorService.submit(taskA);
       }
 
-      this.log.logDebug(Messages.getString("ClusterAwareWriterFailoverHandler.3"));
-      return new WriterFailoverResult(false, false, null, null);
-    } finally {
-      if (!executorService.isTerminated()) {
-        executorService.shutdownNow(); // terminate all remaining tasks
+      WaitForNewWriterHandler taskB =
+          new WaitForNewWriterHandler(
+              taskCompletedLatch,
+              currentTopology,
+              this.topologyService,
+              writerHost,
+              this.connectionProvider,
+              this.readerFailoverHandler,
+              this.readTopologyIntervalMs,
+              this.log);
+      Future<?> futureB = executorService.submit(taskB);
+
+      executorService
+          .shutdown(); // stop accepting new tasks but continue with tasks already in the the pool
+
+      boolean isLatchZero;
+      try {
+        // wait for any task to complete
+        isLatchZero = taskCompletedLatch.await(this.maxFailoverTimeoutMs, TimeUnit.MILLISECONDS);
+      } catch (InterruptedException e) {
+        Thread.currentThread().interrupt();
+        throw createInterruptedException(e);
       }
-    }
-  }
 
-  private int submitTasks(List<HostInfo> currentTopology, ExecutorService executorService,
-                          CompletionService<WriterFailoverResult> completionService) {
-    int numTasks = 0;
-    HostInfo writerHost = currentTopology.isEmpty() ? null : currentTopology.get(WRITER_CONNECTION_INDEX);
-    HostInfo writerHostWithInitialProps = writerHost == null ?
-            null : ClusterAwareUtils.copyWithAdditionalProps(writerHost, this.initialConnectionProps);
-    this.topologyService.addToDownHostList(writerHost);
-    if (writerHostWithInitialProps != null) {
-      completionService.submit(new ReconnectToWriterHandler(writerHostWithInitialProps));
-      numTasks++;
-    }
-    if(!currentTopology.isEmpty()) {
-      completionService.submit(new WaitForNewWriterHandler(currentTopology, writerHostWithInitialProps));
-      numTasks++;
-    }
-    executorService.shutdown();
-    return numTasks;
-  }
+      if (!isLatchZero) {
+        // latch isn't 0 and that means that tasks are not yet finished;
+        // time is out; cancel them
+        if (futureA != null) {
+          futureA.cancel(true);
+        }
+        futureB.cancel(true);
+        return new ResolvedHostInfo(false, false, null, null);
+      }
 
-  private WriterFailoverResult getNextResult(ExecutorService executorService,
-      CompletionService<WriterFailoverResult> completionService) throws SQLException{
-    try {
-      Future<WriterFailoverResult> firstCompleted = completionService.poll(
-              this.maxFailoverTimeoutMs, TimeUnit.MILLISECONDS);
-      if(firstCompleted == null) {
-        // The task was unsuccessful and we have timed out
-        return new WriterFailoverResult(false, false, new ArrayList<>(), null);
+      // latch has passed and that means that either of tasks is almost finished
+      // wait till a task is "officially" done
+      while ((futureA == null || !futureA.isDone()) && !futureB.isDone()) {
+        try {
+          TimeUnit.MILLISECONDS.sleep(1);
+        } catch (InterruptedException e) {
+          Thread.currentThread().interrupt();
+          throw createInterruptedException(e);
+        }
+      }
+
+      if (futureA != null && futureA.isDone()) {
+        if (taskA.isConnected()) {
+          // taskA is completed and connected to writer node
+          // use this connection
+
+          futureB.cancel(true);
+          this.log.logDebug(
+                  Messages.getString(
+                          "ClusterAwareWriterFailoverHandler.2", new Object[]{ writerHost.getHostPortPair() }));
+
+          return new ResolvedHostInfo(
+              true, false, taskA.getTopology(), taskA.getCurrentConnection());
+        } else {
+          // taskA is completed but hasn't connected
+          // wait for taskB to complete
+
+          try {
+            futureB.get(this.maxFailoverTimeoutMs, TimeUnit.MILLISECONDS);
+          } catch (TimeoutException | ExecutionException e) {
+            // time is out; taskB is not connected either
+            this.log.logDebug(Messages.getString("ClusterAwareWriterFailoverHandler.3"));
+            return new ResolvedHostInfo(false, false, null, null);
+          } catch (InterruptedException e) {
+            Thread.currentThread().interrupt();
+            throw createInterruptedException(e);
+          }
+
+          // taskB is completed; check its results
+          if (taskB.isConnected()) {
+            HostInfo newWriterHost = taskB.getTopology().get(WRITER_CONNECTION_INDEX);
+            String newWriterHostPair =
+                newWriterHost == null ? "<null>" : newWriterHost.getHostPortPair();
+            this.log.logDebug(
+                Messages.getString(
+                    "ClusterAwareWriterFailoverHandler.4", new Object[] {newWriterHostPair}));
+
+            return new ResolvedHostInfo(
+                true, true, taskB.getTopology(), taskB.getCurrentConnection());
+          }
+          this.log.logDebug(Messages.getString("ClusterAwareWriterFailoverHandler.3"));
+          return new ResolvedHostInfo(false, false, null, null);
+        }
+      } else if (futureB.isDone()) {
+        if (taskB.isConnected()) {
+          // taskB is done and it's connected to writer node
+          // use this connection
+          if (futureA != null) {
+            futureA.cancel(true);
+          }
+
+          HostInfo newWriterHost = taskB.getTopology().get(WRITER_CONNECTION_INDEX);
+          String newWriterHostPair =
+              newWriterHost == null ? "<null>" : newWriterHost.getHostPortPair();
+          this.log.logDebug(
+              Messages.getString(
+                  "ClusterAwareWriterFailoverHandler.4", new Object[] {newWriterHostPair}));
+
+          return new ResolvedHostInfo(
+              true, true, taskB.getTopology(), taskB.getCurrentConnection());
+        } else if (futureA != null) {
+          // taskB is completed but it's failed to connect to writer node
+          // wait for taskA completes
+
+          try {
+            futureA.get(this.maxFailoverTimeoutMs, TimeUnit.MILLISECONDS);
+          } catch (TimeoutException | ExecutionException e) {
+            // time is out; taskA is not connected either
+            this.log.logDebug(Messages.getString("ClusterAwareWriterFailoverHandler.3"));
+            return new ResolvedHostInfo(false, false, null, null);
+          } catch (InterruptedException e) {
+            Thread.currentThread().interrupt();
+            throw createInterruptedException(e);
+          }
+
+          // taskA is completed; check its results
+          if (taskA.isConnected()) {
+            this.log.logDebug(
+                Messages.getString(
+                    "ClusterAwareWriterFailoverHandler.2", new Object[] { writerHost.getHostPortPair() }));
+            return new ResolvedHostInfo(
+                true, false, taskA.getTopology(), taskA.getCurrentConnection());
+          }
+
+          this.log.logDebug(Messages.getString("ClusterAwareWriterFailoverHandler.3"));
+          return new ResolvedHostInfo(false, false, null, null);
+        }
       }
-      WriterFailoverResult result = firstCompleted.get();
-      if(result.isConnected()) {
-        executorService.shutdownNow();
-        logTaskSuccess(result);
-        return result;
+
+      if (futureA != null) {
+        futureA.cancel(true);
       }
-    } catch (InterruptedException e) {
-      Thread.currentThread().interrupt();
-      throw createInterruptedException(e);
-    } catch (ExecutionException e) {
-      // return failure below
-    }
-    return new WriterFailoverResult(false, false, new ArrayList<>(), null);
-  }
+      futureB.cancel(true);
 
-  private void logTaskSuccess(WriterFailoverResult result) {
-    List<HostInfo> topology = result.getTopology();
-    if(topology == null || topology.isEmpty() || topology.get(WRITER_CONNECTION_INDEX) == null) {
-      String taskId = result.isNewHost() ? "TaskB" : "TaskA";
-      this.log.logError(Messages.getString("ClusterAwareWriterFailoverHandler.5", new Object[] { taskId }));
-      return;
-    }
-    String newWriterHost = topology.get(WRITER_CONNECTION_INDEX).getHostPortPair();
-    if(result.isNewHost()) {
-      this.log.logDebug(Messages.getString("ClusterAwareWriterFailoverHandler.4", new Object[] { newWriterHost }));
-    } else  {
-      this.log.logDebug(Messages.getString("ClusterAwareWriterFailoverHandler.2", new Object[] { newWriterHost }));
+      // both taskA and taskB are unsuccessful
+      this.log.logDebug(Messages.getString("ClusterAwareWriterFailoverHandler.3"));
+      return new ResolvedHostInfo(false, false, null, null);
+    } finally {
+      if (executorService != null && !executorService.isTerminated()) {
+        executorService.shutdownNow(); // terminate all remaining tasks
+      }
     }
   }
 
@@ -207,50 +291,94 @@ public class ClusterAwareWriterFailoverHandler implements WriterFailoverHandler
   }
 
   /** Internal class responsible for re-connecting to the current writer (aka TaskA). */
-  private class ReconnectToWriterHandler implements Callable<WriterFailoverResult> {
-    private final HostInfo originalWriterHost;
+  private static class ReconnectToWriterHandler implements Runnable {
+    private List<HostInfo> latestTopology = null;
+    private final HostInfo currentWriterHost;
+    private final CountDownLatch taskCompletedLatch;
+    private boolean isConnected = false;
+    private JdbcConnection currentConnection = null;
+    private final ConnectionProvider connectionProvider;
+    private final TopologyService topologyService;
+    private final int reconnectWriterIntervalMs;
+    private final transient Log log;
+
+    public ReconnectToWriterHandler(
+        CountDownLatch taskCompletedLatch,
+        HostInfo host,
+        TopologyService topologyService,
+        ConnectionProvider connectionProvider,
+        int reconnectWriterIntervalMs,
+        Log log) {
+      this.taskCompletedLatch = taskCompletedLatch;
+      this.currentWriterHost = host;
+      this.topologyService = topologyService;
+      this.connectionProvider = connectionProvider;
+      this.reconnectWriterIntervalMs = reconnectWriterIntervalMs;
+      this.log = log;
+    }
 
-    public ReconnectToWriterHandler(HostInfo originalWriterHost) {
-      this.originalWriterHost = originalWriterHost;
+    public boolean isConnected() {
+      return this.isConnected;
     }
 
-    public WriterFailoverResult call() {
-      log.logDebug(
-              Messages.getString(
-                      "ClusterAwareWriterFailoverHandler.6",
-                      new Object[] {this.originalWriterHost.getHostPortPair()}));
+    public JdbcConnection getCurrentConnection() {
+      return this.currentConnection;
+    }
+
+    public List<HostInfo> getTopology() {
+      return this.latestTopology;
+    }
+
+    public void run() {
       try {
+        this.log.logTrace(Messages.getString("ClusterAwareWriterFailoverHandler.6"));
         while (true) {
           try {
-            JdbcConnection conn = connectionProvider.connect(this.originalWriterHost);
-
-            List<HostInfo> latestTopology = topologyService.getTopology(conn, true);
-            if (latestTopology != null && !latestTopology.isEmpty() && isCurrentHostWriter(latestTopology)) {
-              topologyService.removeFromDownHostList(this.originalWriterHost);
-              return new WriterFailoverResult(true, false, latestTopology, conn);
+            this.log.logDebug(
+                Messages.getString(
+                    "ClusterAwareWriterFailoverHandler.5",
+                    new Object[] {this.currentWriterHost.getHostPortPair()}));
+
+            JdbcConnection conn = this.connectionProvider.connect(this.currentWriterHost);
+
+            this.latestTopology = this.topologyService.getTopology(conn, true);
+            if (this.latestTopology != null
+                && !this.latestTopology.isEmpty()
+                && isCurrentHostWriter()) {
+              this.isConnected = true;
+              this.currentConnection = conn;
+              this.topologyService.removeFromDownHostList(this.currentWriterHost);
+              return;
             }
           } catch (SQLException exception) {
-            // ignore
+            // eat
           }
 
-          TimeUnit.MILLISECONDS.sleep(reconnectWriterIntervalMs);
+          TimeUnit.MILLISECONDS.sleep(this.reconnectWriterIntervalMs);
         }
       } catch (InterruptedException exception) {
         Thread.currentThread().interrupt();
-        return new WriterFailoverResult(false, false, null, null);
+        this.isConnected = false;
+        this.currentConnection = null;
+        this.latestTopology = null;
       } catch (Exception ex) {
-        log.logError(ex);
+        this.log.logError(ex);
+        this.isConnected = false;
+        this.currentConnection = null;
+        this.latestTopology = null;
         throw ex;
       } finally {
-        log.logTrace(Messages.getString("ClusterAwareWriterFailoverHandler.8"));
+        this.log.logTrace(Messages.getString("ClusterAwareWriterFailoverHandler.7"));
+        // notify that this task is done
+        this.taskCompletedLatch.countDown();
       }
     }
 
-    private boolean isCurrentHostWriter(List<HostInfo> latestTopology) {
+    private boolean isCurrentHostWriter() {
       String currentInstanceName =
-          this.originalWriterHost.getHostProperties().get(TopologyServicePropertyKeys.INSTANCE_NAME);
-      HostInfo latestWriter = latestTopology.get(WRITER_CONNECTION_INDEX);
-      if (currentInstanceName == null || latestWriter == null) {
+          this.currentWriterHost.getHostProperties().get(TopologyServicePropertyKeys.INSTANCE_NAME);
+      HostInfo latestWriter = this.latestTopology.get(WRITER_CONNECTION_INDEX);
+      if (latestWriter == null) {
         return false;
       }
       String latestWriterInstanceName =
@@ -263,74 +391,136 @@ public class ClusterAwareWriterFailoverHandler implements WriterFailoverHandler
    * Internal class responsible for getting latest cluster topology and connecting to a newly
    * elected writer (aka TaskB).
    */
-  private class WaitForNewWriterHandler implements Callable<WriterFailoverResult> {
+  private static class WaitForNewWriterHandler implements Runnable {
+
+    private final CountDownLatch taskCompletedLatch;
+    private List<HostInfo> latestTopology;
     private JdbcConnection currentConnection = null;
+    private boolean isConnected;
+    private final int readTopologyIntervalMs;
+    private final TopologyService topologyService;
     private final HostInfo originalWriterHost;
-    private List<HostInfo> currentTopology;
+    private final ConnectionProvider connectionProvider;
+    private final List<HostInfo> currentTopology;
+    private final ReaderFailoverHandler readerFailoverHandler;
+    private final transient Log log;
     private HostInfo currentReaderHost;
     private JdbcConnection currentReaderConnection;
 
     public WaitForNewWriterHandler(
+        CountDownLatch taskCompletedLatch,
         List<HostInfo> currentTopology,
-        HostInfo currentHost) {
+        TopologyService topologyService,
+        HostInfo currentHost,
+        ConnectionProvider connectionProvider,
+        ReaderFailoverHandler readerFailoverHandler,
+        int readTopologyIntervalMs,
+        Log log) {
+      this.taskCompletedLatch = taskCompletedLatch;
       this.currentTopology = currentTopology;
+      this.topologyService = topologyService;
       this.originalWriterHost = currentHost;
+      this.connectionProvider = connectionProvider;
+      this.readerFailoverHandler = readerFailoverHandler;
+      this.readTopologyIntervalMs = readTopologyIntervalMs;
+      this.log = log;
     }
 
-    public WriterFailoverResult call() {
-      log.logTrace(Messages.getString("ClusterAwareWriterFailoverHandler.9"));
+    public boolean isConnected() {
+      return this.isConnected;
+    }
+
+    public List<HostInfo> getTopology() {
+      return this.latestTopology;
+    }
+
+    public JdbcConnection getCurrentConnection() {
+      return this.currentConnection;
+    }
+
+    public void run() {
+      this.log.logTrace(Messages.getString("ClusterAwareWriterFailoverHandler.8"));
 
       try {
+        if (this.currentTopology == null) {
+          // topology isn't available
+          this.isConnected = false;
+          return;
+        }
+
         boolean success = false;
         while (!success) {
           connectoToReader();
-          success = refreshTopologyAndConnectToNewWriter();
-          if(!success) {
-            closeReaderConnection();
-          }
+          success = connectToNewWriter();
         }
-        return new WriterFailoverResult(true, true, this.currentTopology, this.currentConnection);
+
       } catch (InterruptedException exception) {
         Thread.currentThread().interrupt();
-        return new WriterFailoverResult(false, false, null, null);
+        this.isConnected = false;
+        this.currentConnection = null;
+        this.latestTopology = null;
       } catch (Exception ex) {
-        log.logError(Messages.getString("ClusterAwareWriterFailoverHandler.15", new Object[] { ex.getMessage() }));
+        this.log.logError(ex);
+        this.isConnected = false;
+        this.currentConnection = null;
+        this.latestTopology = null;
         throw ex;
       } finally {
-        performFinalCleanup();
+        // Close reader connection if it's not needed.
+        if (this.currentReaderConnection != null && this.currentConnection != this.currentReaderConnection) {
+          try {
+            this.currentReaderConnection.close();
+          } catch (SQLException e) {
+            // eat
+          }
+        }
+        this.log.logTrace(Messages.getString("ClusterAwareWriterFailoverHandler.9"));
+        this.taskCompletedLatch.countDown();
       }
     }
 
     private void connectoToReader() throws InterruptedException {
+
+      // Close reader connection if it's not needed.
+      try {
+        if (this.currentReaderConnection != null && !this.currentReaderConnection.isClosed()) {
+          this.currentReaderConnection.close();
+        }
+      } catch (SQLException e) {
+        // eat
+      }
+
+      this.currentReaderConnection = null;
+      int connIndex = -1;
+      this.currentReaderHost = null;
+
       while (true) {
         try {
-          ReaderFailoverResult connResult =
-                  readerFailoverHandler.getReaderConnection(this.currentTopology);
-          if(isValidReaderConnection(connResult)) {
-            this.currentReaderConnection = connResult.getConnection();
-            this.currentReaderHost = this.currentTopology.get(connResult.getConnectionIndex());
-            log.logDebug(
+          ConnectionAttemptResult connResult =
+                  this.readerFailoverHandler.getReaderConnection(this.currentTopology);
+          this.currentReaderConnection = connResult != null && connResult.isSuccess() ? connResult.getConnection() : null;
+          connIndex =
+                  connResult != null && connResult.isSuccess() ? connResult.getConnectionIndex() : -1;
+        } catch (SQLException e) {
+          // eat
+        }
+
+        if (this.currentReaderConnection == null) {
+          // can't connect to any reader
+          this.log.logDebug(Messages.getString("ClusterAwareWriterFailoverHandler.11"));
+        } else {
+          this.currentReaderHost = this.currentTopology.get(connIndex);
+          if (currentReaderHost != null) {
+            this.log.logDebug(
                     Messages.getString(
-                            "ClusterAwareWriterFailoverHandler.11",
-                            new Object[]{connResult.getConnectionIndex(), this.currentReaderHost.getHostPortPair()}));
+                            "ClusterAwareWriterFailoverHandler.10",
+                            new Object[]{connIndex, this.currentReaderHost.getHostPortPair()}));
             break;
           }
-        } catch (SQLException e) {
-          // ignore
         }
-        log.logDebug(Messages.getString("ClusterAwareWriterFailoverHandler.12"));
-        TimeUnit.MILLISECONDS.sleep(1);
-      }
-    }
 
-    private boolean isValidReaderConnection(ReaderFailoverResult result) {
-      if(!result.isConnected() || result.getConnection() == null) {
-        return false;
+        TimeUnit.MILLISECONDS.sleep(1);
       }
-      int connIndex = result.getConnectionIndex();
-      return connIndex != ClusterAwareConnectionProxy.NO_CONNECTION_INDEX
-              && connIndex < this.currentTopology.size()
-              && this.currentTopology.get(connIndex) != null;
     }
 
     /**
@@ -338,28 +528,45 @@ public class ClusterAwareWriterFailoverHandler implements WriterFailoverHandler
      *
      * @return Returns true if successful.
      */
-    private boolean refreshTopologyAndConnectToNewWriter() throws InterruptedException {
+    private boolean connectToNewWriter() throws InterruptedException {
       while (true) {
-        this.currentTopology = topologyService.getTopology(this.currentReaderConnection, true);
-        if (this.currentTopology == null) {
+        this.latestTopology = this.topologyService.getTopology(this.currentReaderConnection, true);
+
+        if (this.latestTopology == null) {
           // topology couldn't be obtained; it might be issues with reader connection
           return false;
         }
 
-        if (!this.currentTopology.isEmpty()) {
+        if (!this.latestTopology.isEmpty()) {
+
           logTopology();
-          HostInfo writerCandidate = this.currentTopology.get(WRITER_CONNECTION_INDEX);
+          HostInfo writerCandidate = this.latestTopology.get(WRITER_CONNECTION_INDEX);
 
-          if (writerCandidate != null && (this.originalWriterHost == null
-                  || !isSame(writerCandidate, this.originalWriterHost))) {
+          if (writerCandidate != null && (this.originalWriterHost == null || !isSame(writerCandidate, this.originalWriterHost))) {
             // new writer is available and it's different from the previous writer
-            if (connectToWriter(writerCandidate)) {
+            try {
+              this.log.logDebug(
+                      Messages.getString(
+                              "ClusterAwareWriterFailoverHandler.13",
+                              new Object[] {writerCandidate.getHostPortPair()}));
+
+              if (isSame(writerCandidate, this.currentReaderHost)) {
+                this.currentConnection = this.currentReaderConnection;
+              } else {
+                // connected to a new writer
+                this.currentConnection = this.connectionProvider.connect(writerCandidate);
+              }
+              this.isConnected = true;
+
+              this.topologyService.removeFromDownHostList(writerCandidate);
               return true;
+            } catch (SQLException exception) {
+              this.topologyService.addToDownHostList(writerCandidate);
             }
           }
         }
 
-        TimeUnit.MILLISECONDS.sleep(readTopologyIntervalMs);
+        TimeUnit.MILLISECONDS.sleep(this.readTopologyIntervalMs);
       }
     }
 
@@ -370,72 +577,22 @@ public class ClusterAwareWriterFailoverHandler implements WriterFailoverHandler
       return writerCandidate
           .getHostProperties()
           .get(TopologyServicePropertyKeys.INSTANCE_NAME)
-          .equals(originalWriter.getHostProperties().get(TopologyServicePropertyKeys.INSTANCE_NAME));
-    }
-
-    private boolean connectToWriter(HostInfo writerCandidate) {
-      try {
-        log.logDebug(
-                Messages.getString(
-                        "ClusterAwareWriterFailoverHandler.14",
-                        new Object[] {writerCandidate.getHostPortPair()}));
-
-        if (isSame(writerCandidate, this.currentReaderHost)) {
-          this.currentConnection = this.currentReaderConnection;
-        } else {
-          // connect to the new writer
-          HostInfo writerCandidateWithProps =
-                  ClusterAwareUtils.copyWithAdditionalProps(writerCandidate, initialConnectionProps);
-          this.currentConnection = connectionProvider.connect(writerCandidateWithProps);
-        }
-
-        topologyService.removeFromDownHostList(writerCandidate);
-        return true;
-      } catch (SQLException exception) {
-        topologyService.addToDownHostList(writerCandidate);
-        return false;
-      }
-    }
-
-    /**
-     * Close the reader connection if not done so already, and mark the relevant fields as null
-     */
-    private void closeReaderConnection() {
-      try {
-        if (this.currentReaderConnection != null && !this.currentReaderConnection.isClosed()) {
-          this.currentReaderConnection.close();
-        }
-      } catch (SQLException e) {
-        // ignore
-      }
-      this.currentReaderConnection = null;
-      this.currentReaderHost = null;
-    }
-
-    private void performFinalCleanup() {
-      // Close the reader connection if it's not needed.
-      if (this.currentReaderConnection != null && this.currentConnection != this.currentReaderConnection) {
-        try {
-          this.currentReaderConnection.close();
-        } catch (SQLException e) {
-          // ignore
-        }
-      }
-      log.logTrace(Messages.getString("ClusterAwareWriterFailoverHandler.10"));
+          .equals(
+              originalWriter.getHostProperties().get(TopologyServicePropertyKeys.INSTANCE_NAME));
     }
 
     private void logTopology() {
       StringBuilder msg = new StringBuilder();
-      for (int i = 0; i < this.currentTopology.size(); i++) {
-        HostInfo hostInfo = this.currentTopology.get(i);
+      for (int i = 0; i < this.latestTopology.size(); i++) {
+        HostInfo hostInfo = this.latestTopology.get(i);
         msg.append("\n   [")
             .append(i)
             .append("]: ")
             .append(hostInfo == null ? "<null>" : hostInfo.getHost());
       }
-      log.logTrace(
+      this.log.logTrace(
           Messages.getString(
-                  "ClusterAwareWriterFailoverHandler.13", new Object[] {msg.toString()}));
+              "ClusterAwareWriterFailoverHandler.12", new Object[] {msg.toString()}));
     }
   }
 }
diff --git a/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ReaderFailoverResult.java b/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ConnectionAttemptResult.java
similarity index 92%
rename from src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ReaderFailoverResult.java
rename to src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ConnectionAttemptResult.java
index 64acacb..250c06c 100644
--- a/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ReaderFailoverResult.java
+++ b/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ConnectionAttemptResult.java
@@ -33,19 +33,19 @@ package com.mysql.cj.jdbc.ha.ca;
 import com.mysql.cj.jdbc.JdbcConnection;
 
 /** This class holds results of Reader Failover Process. */
-public class ReaderFailoverResult {
+public class ConnectionAttemptResult {
   private final JdbcConnection newConnection;
   private final int newConnectionIndex;
-  private final boolean isConnected;
+  private final boolean success;
 
   /**
    * ConnectionAttemptResult constructor.
    * */
-  public ReaderFailoverResult(
-      JdbcConnection newConnection, int newConnectionIndex, boolean isConnected) {
+  public ConnectionAttemptResult(
+      JdbcConnection newConnection, int newConnectionIndex, boolean success) {
     this.newConnection = newConnection;
     this.newConnectionIndex = newConnectionIndex;
-    this.isConnected = isConnected;
+    this.success = success;
   }
 
   /**
@@ -73,7 +73,7 @@ public class ReaderFailoverResult {
    *
    * @return True, if process successfully connected to a host.
    */
-  public boolean isConnected() {
-    return isConnected;
+  public boolean isSuccess() {
+    return success;
   }
 }
diff --git a/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ReaderFailoverHandler.java b/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ReaderFailoverHandler.java
index b957f34..ceb7870 100644
--- a/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ReaderFailoverHandler.java
+++ b/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ReaderFailoverHandler.java
@@ -48,16 +48,18 @@ public interface ReaderFailoverHandler {
    *
    * @param hosts Cluster current topology.
    * @param currentHost The currently connected host that has failed.
-   * @return {@link ReaderFailoverResult} The results of this process.
+   * @return {@link ConnectionAttemptResult} The results of this process. May return null, which is
+   *     considered an unsuccessful result.
    */
-  ReaderFailoverResult failover(List<HostInfo> hosts, HostInfo currentHost) throws SQLException;
+  ConnectionAttemptResult failover(List<HostInfo> hosts, HostInfo currentHost) throws SQLException;
 
   /**
    * Called to get any available reader connection. If no reader is available then result of process
    * is unsuccessful. This process will not attempt to connect to the writer host.
    *
    * @param hostList Cluster current topology.
-   * @return {@link ReaderFailoverResult} The results of this process.
+   * @return {@link ConnectionAttemptResult} The results of this process. May return null, which is
+   *     considered an unsuccessful result.
    */
-  ReaderFailoverResult getReaderConnection(List<HostInfo> hostList) throws SQLException;
+  ConnectionAttemptResult getReaderConnection(List<HostInfo> hostList) throws SQLException;
 }
diff --git a/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/WriterFailoverResult.java b/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ResolvedHostInfo.java
similarity index 96%
rename from src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/WriterFailoverResult.java
rename to src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ResolvedHostInfo.java
index 6970fd6..ee7ea0a 100644
--- a/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/WriterFailoverResult.java
+++ b/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/ResolvedHostInfo.java
@@ -36,7 +36,7 @@ import com.mysql.cj.jdbc.JdbcConnection;
 import java.util.List;
 
 /** This class holds results of Writer Failover Process. */
-public class WriterFailoverResult {
+public class ResolvedHostInfo {
   private final boolean isConnected;
   private final boolean isNewHost;
   private final List<HostInfo> topology;
@@ -45,7 +45,7 @@ public class WriterFailoverResult {
   /**
    * ResolvedHostInfo constructor.
    * */
-  public WriterFailoverResult(
+  public ResolvedHostInfo(
       boolean isConnected,
       boolean isNewHost,
       List<HostInfo> topology,
@@ -86,7 +86,7 @@ public class WriterFailoverResult {
   }
 
   /**
-   * Get connection to a host.
+   * Get new connection to a host.
    *
    * @return {@link JdbcConnection} New connection to a host. Returns null if no connection is
    *     established.
diff --git a/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/TopologyService.java b/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/TopologyService.java
index ac52bea..2405397 100644
--- a/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/TopologyService.java
+++ b/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/TopologyService.java
@@ -63,9 +63,9 @@ public interface TopologyService {
    *
    * <p>Examples: "?.mydomain.com", "db-instance.?.mydomain.com"
    *
-   * @param clusterInstanceTemplate Cluster instance details including host dns pattern.
+   * @param clusterInstanceHost Cluster instance details including host dns pattern.
    */
-  void setClusterInstanceTemplate(HostInfo clusterInstanceTemplate);
+  void setClusterInstanceHost(HostInfo clusterInstanceHost);
 
   /**
    * Get cluster topology. A writer host is always at position 0.
diff --git a/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/WriterFailoverHandler.java b/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/WriterFailoverHandler.java
index 32f6094..34286b7 100644
--- a/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/WriterFailoverHandler.java
+++ b/src/main/user-impl/java/com/mysql/cj/jdbc/ha/ca/WriterFailoverHandler.java
@@ -45,8 +45,8 @@ public interface WriterFailoverHandler {
    * Called to start Writer Failover Process.
    *
    * @param currentTopology Cluster current topology
-   * @return {@link WriterFailoverResult} The results of this process. May return null, which is
+   * @return {@link ResolvedHostInfo} The results of this process. May return null, which is
    *     considered an unsuccessful result.
    */
-  WriterFailoverResult failover(List<HostInfo> currentTopology) throws SQLException;
+  ResolvedHostInfo failover(List<HostInfo> currentTopology) throws SQLException;
 }
diff --git a/src/main/user-impl/java/software/aws/rds/jdbc/mysql/Driver.java b/src/main/user-impl/java/software/aws/rds/jdbc/mysql/Driver.java
index 9460c18..bb8cde0 100644
--- a/src/main/user-impl/java/software/aws/rds/jdbc/mysql/Driver.java
+++ b/src/main/user-impl/java/software/aws/rds/jdbc/mysql/Driver.java
@@ -61,21 +61,6 @@ public class Driver extends NonRegisteringDriver implements java.sql.Driver {
     }
   }
 
-  /**
-   * Set the acceptAwsProtocolOnly property for the driver, which controls whether protocols other than
-   * jdbc:postgresql:aws:// will be accepted by the driver. This setting should be set to true when
-   * running an application that uses this driver simultaneously with another MySQL
-   * driver that supports the same protocols (eg the MySQL JDBC Driver), to ensure the driver
-   * protocols do not clash. The property can also be set at the connection level via a connection
-   * parameter, which will take priority over this driver-level property.
-   *
-   * @param awsProtocolOnly enables the acceptAwsProtocolOnly mode of the driver
-   */
-  public static void setAcceptAwsProtocolOnly(boolean awsProtocolOnly) {
-    acceptAwsProtocolOnly = awsProtocolOnly;
-  }
-
-
   static {
     System.out.println("You are using Amazon Web Services (AWS) JDBC Driver for MySQL, you can also use 'software.aws.rds.jdbc.mysql.Driver()' to register");
   }
diff --git a/src/test/java/com/mysql/cj/jdbc/NonRegisteringDriverTest.java b/src/test/java/com/mysql/cj/jdbc/NonRegisteringDriverTest.java
index 2772d61..5ec518f 100644
--- a/src/test/java/com/mysql/cj/jdbc/NonRegisteringDriverTest.java
+++ b/src/test/java/com/mysql/cj/jdbc/NonRegisteringDriverTest.java
@@ -1,86 +1,27 @@
-/*
- * AWS JDBC Driver for MySQL
- * Copyright Amazon.com Inc. or affiliates.
- *
- * This program is free software; you can redistribute it and/or modify it under
- * the terms of the GNU General Public License, version 2.0, as published by the
- * Free Software Foundation.
- *
- * This program is also distributed with certain software (including but not
- * limited to OpenSSL) that is licensed under separate terms, as designated in a
- * particular file or component or in included license documentation. The
- * authors of this program hereby grant you an additional permission to link the
- * program and your derivative works with the separately licensed software that
- * they have included with MySQL.
- *
- * Without limiting anything contained in the foregoing, this file, which is
- * part of this connector, is also subject to the Universal FOSS Exception,
- * version 1.0, a copy of which can be found at
- * http://oss.oracle.com/licenses/universal-foss-exception.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- * FOR A PARTICULAR PURPOSE. See the GNU General Public License, version 2.0,
- * for more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA
- */
-
 package com.mysql.cj.jdbc;
 
 import com.mysql.cj.conf.ConnectionUrl;
 import com.mysql.cj.jdbc.ha.*;
 import com.mysql.cj.jdbc.ha.ca.ClusterAwareConnectionProxy;
-import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 import org.mockito.MockedStatic;
 import org.mockito.Mockito;
 
-import java.lang.reflect.Method;
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.util.Properties;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
 import static org.junit.jupiter.api.Assertions.*;
 import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.*;
 
+@SuppressWarnings("unchecked")
 public class NonRegisteringDriverTest {
-
-    @BeforeEach
-    public void setAwsProtocolOnlyToFalse() {
-        software.aws.rds.jdbc.mysql.Driver.setAcceptAwsProtocolOnly(false);
-    }
-
-    @Test
-    public void testSetAwsProtocolOnlySwitch() throws Exception {
-        software.aws.rds.jdbc.mysql.Driver drv = new software.aws.rds.jdbc.mysql.Driver();
-        assertNotNull(drv);
-
-        assertFalse(drv.acceptsURL("jdbc:mysql://localhost:5432/test?acceptAwsProtocolOnly=true"));
-        assertTrue(drv.acceptsURL("jdbc:mysql://localhost:5432/test?acceptAwsProtocolOnly=false"));
-
-        software.aws.rds.jdbc.mysql.Driver.setAcceptAwsProtocolOnly(true);
-        assertFalse(drv.acceptsURL("jdbc:mysql://localhost:5432/test"));
-        assertTrue(drv.acceptsURL("jdbc:mysql:aws://localhost:5432/test"));
-
-        // Check if the connection property is prioritized over the global setting.
-        assertTrue(drv.acceptsURL("jdbc:mysql://localhost:5432/test?acceptAwsProtocolOnly=false"));
-
-        software.aws.rds.jdbc.mysql.Driver.setAcceptAwsProtocolOnly(false);
-        assertTrue(drv.acceptsURL("jdbc:mysql://localhost:5432/test"));
-        assertTrue(drv.acceptsURL("jdbc:mysql:aws://localhost:5432/test"));
-
-        assertFalse(drv.acceptsURL("jdbc:mysql://localhost:5432/test?acceptAwsProtocolOnly=true"));
-        assertTrue(drv.acceptsURL("jdbc:mysql://localhost:5432/test?acceptAwsProtocolOnly=false"));
-    }
-
+    // TODO: test method javadocs and license headers for all added files
+    /**
+     * Tests {@link ClusterAwareConnectionProxy} return original connection if failover is not
+     * enabled.
+     */
     @Test
     public void testSingleConnectionProtocolReturnsConnectionImpl() throws SQLException {
         String url = "jdbc:mysql://somehost:1234/test";
@@ -88,7 +29,7 @@ public class NonRegisteringDriverTest {
         ConnectionUrl connUrl = ConnectionUrl.getConnectionUrlInstance(url, new Properties());
         NonRegisteringDriver driver = new NonRegisteringDriver();
 
-        try (MockedStatic<ConnectionImpl> mockStaticConnectionImpl = mockStatic(ConnectionImpl.class)) {
+        try (MockedStatic mockStaticConnectionImpl = mockStatic(ConnectionImpl.class)) {
             mockStaticConnectionImpl.when(() -> ConnectionImpl.getInstance(eq(connUrl.getMainHost()))).thenReturn(mockConnectionImplConn);
             Connection conn = driver.connect(url, new Properties());
             assertEquals(mockConnectionImplConn, conn);
@@ -102,7 +43,7 @@ public class NonRegisteringDriverTest {
         ConnectionUrl connUrl = ConnectionUrl.getConnectionUrlInstance(url, new Properties());
         NonRegisteringDriver driver = new NonRegisteringDriver();
 
-        try (MockedStatic<ClusterAwareConnectionProxy> mockStaticClusterAwareConnectionProxy = mockStatic(ClusterAwareConnectionProxy.class)) {
+        try (MockedStatic mockStaticClusterAwareConnectionProxy = mockStatic(ClusterAwareConnectionProxy.class)) {
             mockStaticClusterAwareConnectionProxy.when(() -> ClusterAwareConnectionProxy.autodetectClusterAndCreateProxyInstance(eq(connUrl))).thenReturn(mockAwsProtocolConn);
             Connection conn = driver.connect(url, new Properties());
             assertEquals(mockAwsProtocolConn, conn);
@@ -116,7 +57,7 @@ public class NonRegisteringDriverTest {
         ConnectionUrl connUrl = ConnectionUrl.getConnectionUrlInstance(url, new Properties());
         NonRegisteringDriver driver = new NonRegisteringDriver();
 
-        try (MockedStatic<FailoverConnectionProxy> mockStaticFailoverConnectionProxy = mockStatic(FailoverConnectionProxy.class)) {
+        try (MockedStatic mockStaticFailoverConnectionProxy = mockStatic(FailoverConnectionProxy.class)) {
             mockStaticFailoverConnectionProxy.when(() -> FailoverConnectionProxy.createProxyInstance(eq(connUrl))).thenReturn(mockFailoverProtocolConn);
             Connection conn = driver.connect(url, new Properties());
             assertEquals(mockFailoverProtocolConn, conn);
@@ -130,7 +71,7 @@ public class NonRegisteringDriverTest {
         ConnectionUrl connUrl = ConnectionUrl.getConnectionUrlInstance(url, new Properties());
         NonRegisteringDriver driver = new NonRegisteringDriver();
 
-        try (MockedStatic<LoadBalancedConnectionProxy> mockStaticLoadBalancedConnectionProxy = mockStatic(LoadBalancedConnectionProxy.class)) {
+        try (MockedStatic mockStaticLoadBalancedConnectionProxy = mockStatic(LoadBalancedConnectionProxy.class)) {
             mockStaticLoadBalancedConnectionProxy.when(() -> LoadBalancedConnectionProxy.createProxyInstance(eq(connUrl))).thenReturn(mockLoadBalancedProtocolConn);
             Connection conn = driver.connect(url, new Properties());
             assertEquals(mockLoadBalancedProtocolConn, conn);
@@ -144,7 +85,7 @@ public class NonRegisteringDriverTest {
         ConnectionUrl connUrl = ConnectionUrl.getConnectionUrlInstance(url, new Properties());
         NonRegisteringDriver driver = new NonRegisteringDriver();
 
-        try (MockedStatic<ReplicationConnectionProxy> mockStaticReplicationConnectionProxy = mockStatic(ReplicationConnectionProxy.class)) {
+        try (MockedStatic mockStaticReplicationConnectionProxy = mockStatic(ReplicationConnectionProxy.class)) {
             mockStaticReplicationConnectionProxy.when(() -> ReplicationConnectionProxy.createProxyInstance(eq(connUrl))).thenReturn(mockReplicationProtocolConn);
             Connection replicationConn = driver.connect(url, new Properties());
             assertEquals(mockReplicationProtocolConn, replicationConn);
diff --git a/src/test/java/com/mysql/cj/jdbc/ha/ca/AuroraTopologyServiceTest.java b/src/test/java/com/mysql/cj/jdbc/ha/ca/AuroraTopologyServiceTest.java
index 6fa04ed..1858cdc 100644
--- a/src/test/java/com/mysql/cj/jdbc/ha/ca/AuroraTopologyServiceTest.java
+++ b/src/test/java/com/mysql/cj/jdbc/ha/ca/AuroraTopologyServiceTest.java
@@ -32,11 +32,11 @@ package com.mysql.cj.jdbc.ha.ca;
 
 import com.mysql.cj.conf.ConnectionUrl;
 import com.mysql.cj.conf.HostInfo;
+import com.mysql.cj.conf.PropertyKey;
 import com.mysql.cj.jdbc.ConnectionImpl;
 import com.mysql.cj.jdbc.JdbcConnection;
 import com.mysql.cj.jdbc.StatementImpl;
 import com.mysql.cj.jdbc.result.ResultSetImpl;
-import com.mysql.cj.log.Log;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 import org.mockito.Mockito;
@@ -62,12 +62,12 @@ import static org.mockito.Mockito.when;
 /** AuroraTopologyServiceTest class. */
 public class AuroraTopologyServiceTest {
 
-  private final AuroraTopologyService spyProvider = Mockito.spy(new AuroraTopologyService(Mockito.mock(Log.class)));
+  private final AuroraTopologyService spyProvider = Mockito.spy(new AuroraTopologyService());
 
   @BeforeEach
   void resetProvider() {
     spyProvider.setClusterId(UUID.randomUUID().toString());
-    spyProvider.setClusterInstanceTemplate(new HostInfo(null, "?", HostInfo.NO_PORT, null, null));
+    spyProvider.setClusterInstanceHost(new HostInfo(null, "?", HostInfo.NO_PORT, null, null));
     spyProvider.setRefreshRate(AuroraTopologyService.DEFAULT_REFRESH_RATE_IN_MILLISECONDS);
     spyProvider.clearAll();
     AuroraTopologyService.setExpireTime(AuroraTopologyService.DEFAULT_CACHE_EXPIRE_MS);
@@ -82,6 +82,7 @@ public class AuroraTopologyServiceTest {
     final String url =
         "jdbc:mysql:aws://my-cluster-name.cluster-XYZ.us-east-2.rds.amazonaws.com:1234/test";
     final Properties mainHostProps = new Properties();
+    mainHostProps.put("anyCustomProperty", "anyTestValue");
     final ConnectionUrl conStr = ConnectionUrl.getConnectionUrlInstance(url, mainHostProps);
     final HostInfo mainHost = conStr.getMainHost();
 
@@ -94,7 +95,7 @@ public class AuroraTopologyServiceTest {
             mainHost.getPassword(),
             mainHost.isPasswordless(),
             mainHost.getHostProperties());
-    spyProvider.setClusterInstanceTemplate(clusterInstanceInfo);
+    spyProvider.setClusterInstanceHost(clusterInstanceInfo);
 
     final List<HostInfo> topology = spyProvider.getTopology(mockConn, false);
 
@@ -114,6 +115,8 @@ public class AuroraTopologyServiceTest {
         AuroraTopologyService.WRITER_SESSION_ID, props.get(TopologyServicePropertyKeys.SESSION_ID));
     assertEquals("2020-09-15 17:51:53.0", props.get(TopologyServicePropertyKeys.LAST_UPDATED));
     assertEquals("13.5", props.get(TopologyServicePropertyKeys.REPLICA_LAG));
+    assertEquals("test", props.get(PropertyKey.DBNAME.getKeyName()));
+    assertEquals("anyTestValue", props.get("anyCustomProperty"));
 
     assertFalse(spyProvider.isMultiWriterCluster());
     assertEquals(3, topology.size());
@@ -140,7 +143,7 @@ public class AuroraTopologyServiceTest {
             mainHost.getPassword(),
             mainHost.isPasswordless(),
             mainHost.getHostProperties());
-    spyProvider.setClusterInstanceTemplate(clusterInstanceInfo);
+    spyProvider.setClusterInstanceHost(clusterInstanceInfo);
 
     final List<HostInfo> topology = spyProvider.getTopology(mockConn, false);
     final List<HostInfo> readers =
@@ -179,6 +182,7 @@ public class AuroraTopologyServiceTest {
         props1.get(TopologyServicePropertyKeys.SESSION_ID));
     assertEquals("2020-09-15 17:51:53.0", props1.get(TopologyServicePropertyKeys.LAST_UPDATED));
     assertEquals("13.5", props1.get(TopologyServicePropertyKeys.REPLICA_LAG));
+    assertEquals("test", props1.get(PropertyKey.DBNAME.getKeyName()));
 
     Map<String, String> props2 = master2.getHostProperties();
     assertEquals("writer-instance-2", props2.get(TopologyServicePropertyKeys.INSTANCE_NAME));
@@ -187,6 +191,7 @@ public class AuroraTopologyServiceTest {
         props2.get(TopologyServicePropertyKeys.SESSION_ID));
     assertEquals("2020-09-15 17:51:53.0", props2.get(TopologyServicePropertyKeys.LAST_UPDATED));
     assertEquals("13.5", props2.get(TopologyServicePropertyKeys.REPLICA_LAG));
+    assertEquals("test", props2.get(PropertyKey.DBNAME.getKeyName()));
 
     Map<String, String> props3 = master3.getHostProperties();
     assertEquals("writer-instance-3", props3.get(TopologyServicePropertyKeys.INSTANCE_NAME));
@@ -195,6 +200,7 @@ public class AuroraTopologyServiceTest {
         props3.get(TopologyServicePropertyKeys.SESSION_ID));
     assertEquals("2020-09-15 17:51:53.0", props3.get(TopologyServicePropertyKeys.LAST_UPDATED));
     assertEquals("13.5", props3.get(TopologyServicePropertyKeys.REPLICA_LAG));
+    assertEquals("test", props3.get(PropertyKey.DBNAME.getKeyName()));
   }
 
   private void stubTopologyQuery(Connection conn, Statement stmt, ResultSet results)
@@ -280,7 +286,7 @@ public class AuroraTopologyServiceTest {
             mainHost.getPassword(),
             mainHost.isPasswordless(),
             mainHost.getHostProperties());
-    spyProvider.setClusterInstanceTemplate(clusterInstanceInfo);
+    spyProvider.setClusterInstanceHost(clusterInstanceInfo);
 
     spyProvider.getTopology(mockConn, false);
     spyProvider.getTopology(mockConn, false);
@@ -304,7 +310,7 @@ public class AuroraTopologyServiceTest {
             mainHost.getPassword(),
             mainHost.isPasswordless(),
             mainHost.getHostProperties());
-    spyProvider.setClusterInstanceTemplate(clusterInstanceInfo);
+    spyProvider.setClusterInstanceHost(clusterInstanceInfo);
     when(mockConn.createStatement()).thenThrow(SQLException.class);
 
     final List<HostInfo> hosts = spyProvider.getTopology(mockConn, true);
@@ -330,7 +336,7 @@ public class AuroraTopologyServiceTest {
             mainHost.getPassword(),
             mainHost.isPasswordless(),
             mainHost.getHostProperties());
-    spyProvider.setClusterInstanceTemplate(clusterInstanceInfo);
+    spyProvider.setClusterInstanceHost(clusterInstanceInfo);
     spyProvider.setRefreshRate(1);
 
     final List<HostInfo> hosts = spyProvider.getTopology(mockConn, false);
@@ -416,7 +422,7 @@ public class AuroraTopologyServiceTest {
             mainHost.getPassword(),
             mainHost.isPasswordless(),
             mainHost.getHostProperties());
-    spyProvider.setClusterInstanceTemplate(clusterInstanceInfo);
+    spyProvider.setClusterInstanceHost(clusterInstanceInfo);
 
     spyProvider.setRefreshRate(1);
     spyProvider.getTopology(mockConn, false);
@@ -446,7 +452,7 @@ public class AuroraTopologyServiceTest {
             mainHost.getPassword(),
             mainHost.isPasswordless(),
             mainHost.getHostProperties());
-    spyProvider.setClusterInstanceTemplate(clusterInstanceInfo);
+    spyProvider.setClusterInstanceHost(clusterInstanceInfo);
 
     AuroraTopologyService.setExpireTime(1000); // 1 sec
     spyProvider.setRefreshRate(
@@ -491,7 +497,7 @@ public class AuroraTopologyServiceTest {
             mainHost.getPassword(),
             mainHost.isPasswordless(),
             mainHost.getHostProperties());
-    spyProvider.setClusterInstanceTemplate(clusterInstanceInfo);
+    spyProvider.setClusterInstanceHost(clusterInstanceInfo);
 
     AuroraTopologyService.setExpireTime(10000); // 10 sec
     spyProvider.setRefreshRate(1000); // 1 sec
@@ -530,7 +536,7 @@ public class AuroraTopologyServiceTest {
             mainHost.getPassword(),
             mainHost.isPasswordless(),
             mainHost.getHostProperties());
-    spyProvider.setClusterInstanceTemplate(clusterInstanceInfo);
+    spyProvider.setClusterInstanceHost(clusterInstanceInfo);
 
     spyProvider.getTopology(mockConn, false);
     spyProvider.addToDownHostList(clusterInstanceInfo);
diff --git a/src/test/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareConnectionProxyTest.java b/src/test/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareConnectionProxyTest.java
index 763eee2..62fc004 100644
--- a/src/test/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareConnectionProxyTest.java
+++ b/src/test/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareConnectionProxyTest.java
@@ -32,13 +32,13 @@ package com.mysql.cj.jdbc.ha.ca;
 
 import com.mysql.cj.Messages;
 import com.mysql.cj.NativeSession;
-import com.mysql.cj.conf.BooleanPropertyDefinition;
-import com.mysql.cj.conf.ConnectionUrl;
 import com.mysql.cj.conf.HostInfo;
-import com.mysql.cj.conf.IntegerPropertyDefinition;
-import com.mysql.cj.conf.PropertyDefinitions;
+import com.mysql.cj.conf.ConnectionUrl;
 import com.mysql.cj.conf.PropertyKey;
 import com.mysql.cj.conf.RuntimeProperty;
+import com.mysql.cj.conf.BooleanPropertyDefinition;
+import com.mysql.cj.conf.IntegerPropertyDefinition;
+import com.mysql.cj.conf.PropertyDefinitions;
 import com.mysql.cj.jdbc.ConnectionImpl;
 import com.mysql.cj.jdbc.JdbcConnection;
 import com.mysql.cj.jdbc.JdbcPropertySet;
@@ -50,21 +50,22 @@ import org.mockito.Mockito;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Map;
+import java.util.HashMap;
 import java.util.Properties;
 
-import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
-import static org.junit.jupiter.api.Assertions.assertNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 import static org.junit.jupiter.api.Assertions.assertSame;
 import static org.junit.jupiter.api.Assertions.assertThrows;
-import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNull;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.eq;
-import static org.mockito.ArgumentMatchers.refEq;
+import static org.mockito.Mockito.when;
+import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.atLeastOnce;
 import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
 
 /**
  * ClusterAwareConnectionProxyTest class.
@@ -110,12 +111,10 @@ public class ClusterAwareConnectionProxyTest {
     final ConnectionProvider mockConnectionProvider = Mockito.mock(ConnectionProvider.class);
     when(mockConnectionProvider.connect(any(HostInfo.class))).thenReturn(mockConn);
 
-    HostInfo writerHost = ClusterAwareTestUtils.createBasicHostInfo("writer", "test");
     final List<HostInfo> mockTopology = new ArrayList<>();
-    mockTopology.add(writerHost);
+    mockTopology.add(Mockito.mock(HostInfo.class));
     when(mockTopologyService.getTopology(eq(mockConn), any(Boolean.class)))
-            .thenReturn(mockTopology);
-    when(mockTopologyService.getHostByName(mockConn)).thenReturn(writerHost);
+        .thenReturn(mockTopology);
 
     final ClusterAwareConnectionProxy proxy =
         new ClusterAwareConnectionProxy(
@@ -126,7 +125,7 @@ public class ClusterAwareConnectionProxyTest {
     assertTrue(proxy.isClusterTopologyAvailable());
     assertTrue(proxy.isFailoverEnabled());
     verify(mockTopologyService, never()).setClusterId(any());
-    verify(mockTopologyService, atLeastOnce()).setClusterInstanceTemplate(any());
+    verify(mockTopologyService, atLeastOnce()).setClusterInstanceHost(any());
   }
 
   private void stubPropertySet(JdbcConnection mockConn) {
@@ -186,12 +185,10 @@ public class ClusterAwareConnectionProxyTest {
     ConnectionProvider mockConnectionProvider = Mockito.mock(ConnectionProvider.class);
     when(mockConnectionProvider.connect(any(HostInfo.class))).thenReturn(mockConn);
 
-    HostInfo writerHost = ClusterAwareTestUtils.createBasicHostInfo("writer", "test");
     final List<HostInfo> mockTopology = new ArrayList<>();
-    mockTopology.add(writerHost);
+    mockTopology.add(Mockito.mock(HostInfo.class));
     when(mockTopologyService.getTopology(eq(mockConn), any(Boolean.class)))
-            .thenReturn(mockTopology);
-    when(mockTopologyService.getHostByName(mockConn)).thenReturn(writerHost);
+        .thenReturn(mockTopology);
 
     assertThrows(
         SQLException.class,
@@ -218,12 +215,10 @@ public class ClusterAwareConnectionProxyTest {
     final ConnectionUrl conStr = ConnectionUrl.getConnectionUrlInstance(url, new Properties());
     final TopologyService mockTopologyService = Mockito.mock(TopologyService.class);
 
-    HostInfo writerHost = ClusterAwareTestUtils.createBasicHostInfo("writer", "test");
     final List<HostInfo> mockTopology = new ArrayList<>();
-    mockTopology.add(writerHost);
+    mockTopology.add(Mockito.mock(HostInfo.class));
     when(mockTopologyService.getTopology(eq(mockConn), any(Boolean.class)))
-            .thenReturn(mockTopology);
-    when(mockTopologyService.getHostByName(mockConn)).thenReturn(writerHost);
+        .thenReturn(mockTopology);
 
     final WriterFailoverHandler writerFailoverHandler = Mockito.mock(WriterFailoverHandler.class);
     final ReaderFailoverHandler readerFailoverHandler = Mockito.mock(ReaderFailoverHandler.class);
@@ -242,7 +237,7 @@ public class ClusterAwareConnectionProxyTest {
     assertTrue(proxy.isFailoverEnabled());
     verify(mockTopologyService, atLeastOnce())
         .setClusterId("my-cluster-name.cluster-XYZ.us-east-2.rds.amazonaws.com:1234");
-    verify(mockTopologyService, atLeastOnce()).setClusterInstanceTemplate(any());
+    verify(mockTopologyService, atLeastOnce()).setClusterInstanceHost(any());
   }
 
   @Test
@@ -263,12 +258,10 @@ public class ClusterAwareConnectionProxyTest {
     final ConnectionUrl conStr = ConnectionUrl.getConnectionUrlInstance(url, new Properties());
     final TopologyService mockTopologyService = Mockito.mock(TopologyService.class);
 
-    HostInfo writerHost = ClusterAwareTestUtils.createBasicHostInfo("writer", "test");
     final List<HostInfo> mockTopology = new ArrayList<>();
-    mockTopology.add(writerHost);
+    mockTopology.add(Mockito.mock(HostInfo.class));
     when(mockTopologyService.getTopology(eq(mockConn), any(Boolean.class)))
-            .thenReturn(mockTopology);
-    when(mockTopologyService.getHostByName(mockConn)).thenReturn(writerHost);
+        .thenReturn(mockTopology);
 
     final WriterFailoverHandler writerFailoverHandler = Mockito.mock(WriterFailoverHandler.class);
     final ReaderFailoverHandler readerFailoverHandler = Mockito.mock(ReaderFailoverHandler.class);
@@ -287,7 +280,7 @@ public class ClusterAwareConnectionProxyTest {
     assertTrue(proxy.isFailoverEnabled());
     verify(mockTopologyService, atLeastOnce())
         .setClusterId("my-cluster-name.cluster-XYZ.us-east-2.rds.amazonaws.com:1234");
-    verify(mockTopologyService, atLeastOnce()).setClusterInstanceTemplate(any());
+    verify(mockTopologyService, atLeastOnce()).setClusterInstanceHost(any());
   }
 
   @Test
@@ -308,12 +301,10 @@ public class ClusterAwareConnectionProxyTest {
     final ConnectionUrl conStr = ConnectionUrl.getConnectionUrlInstance(url, new Properties());
     final TopologyService mockTopologyService = Mockito.mock(TopologyService.class);
 
-    HostInfo writerHost = ClusterAwareTestUtils.createBasicHostInfo("writer", "test");
     final List<HostInfo> mockTopology = new ArrayList<>();
-    mockTopology.add(writerHost);
+    mockTopology.add(Mockito.mock(HostInfo.class));
     when(mockTopologyService.getTopology(eq(mockConn), any(Boolean.class)))
-            .thenReturn(mockTopology);
-    when(mockTopologyService.getHostByName(mockConn)).thenReturn(writerHost);
+        .thenReturn(mockTopology);
 
     final WriterFailoverHandler writerFailoverHandler = Mockito.mock(WriterFailoverHandler.class);
     final ReaderFailoverHandler readerFailoverHandler = Mockito.mock(ReaderFailoverHandler.class);
@@ -331,7 +322,7 @@ public class ClusterAwareConnectionProxyTest {
     assertTrue(proxy.isClusterTopologyAvailable());
     assertTrue(proxy.isFailoverEnabled());
     verify(mockTopologyService, never()).setClusterId(any());
-    verify(mockTopologyService, atLeastOnce()).setClusterInstanceTemplate(any());
+    verify(mockTopologyService, atLeastOnce()).setClusterInstanceHost(any());
   }
 
   @Test
@@ -351,12 +342,10 @@ public class ClusterAwareConnectionProxyTest {
     final ConnectionUrl conStr = ConnectionUrl.getConnectionUrlInstance(url, new Properties());
     final TopologyService mockTopologyService = Mockito.mock(TopologyService.class);
 
-    HostInfo writerHost = ClusterAwareTestUtils.createBasicHostInfo("writer", "test");
     final List<HostInfo> mockTopology = new ArrayList<>();
-    mockTopology.add(writerHost);
+    mockTopology.add(Mockito.mock(HostInfo.class));
     when(mockTopologyService.getTopology(eq(mockConn), any(Boolean.class)))
-            .thenReturn(mockTopology);
-    when(mockTopologyService.getHostByName(mockConn)).thenReturn(writerHost);
+        .thenReturn(mockTopology);
 
     final WriterFailoverHandler writerFailoverHandler = Mockito.mock(WriterFailoverHandler.class);
     final ReaderFailoverHandler readerFailoverHandler = Mockito.mock(ReaderFailoverHandler.class);
@@ -374,7 +363,7 @@ public class ClusterAwareConnectionProxyTest {
     assertTrue(proxy.isClusterTopologyAvailable());
     assertTrue(proxy.isFailoverEnabled());
     verify(mockTopologyService, never()).setClusterId(any());
-    verify(mockTopologyService, atLeastOnce()).setClusterInstanceTemplate(any());
+    verify(mockTopologyService, atLeastOnce()).setClusterInstanceHost(any());
   }
 
   @Test
@@ -416,7 +405,7 @@ public class ClusterAwareConnectionProxyTest {
     assertFalse(proxy.isFailoverEnabled());
     verify(mockTopologyService, atLeastOnce())
         .setClusterId("test-proxy.proxy-XYZ.us-east-2.rds.amazonaws.com:1234");
-    verify(mockTopologyService, atLeastOnce()).setClusterInstanceTemplate(any());
+    verify(mockTopologyService, atLeastOnce()).setClusterInstanceHost(any());
   }
 
   @Test
@@ -439,12 +428,10 @@ public class ClusterAwareConnectionProxyTest {
     final ConnectionUrl conStr = ConnectionUrl.getConnectionUrlInstance(url, new Properties());
     final TopologyService mockTopologyService = Mockito.mock(TopologyService.class);
 
-    HostInfo writerHost = ClusterAwareTestUtils.createBasicHostInfo("writer", "test");
     final List<HostInfo> mockTopology = new ArrayList<>();
-    mockTopology.add(writerHost);
+    mockTopology.add(Mockito.mock(HostInfo.class));
     when(mockTopologyService.getTopology(eq(mockConn), any(Boolean.class)))
-            .thenReturn(mockTopology);
-    when(mockTopologyService.getHostByName(mockConn)).thenReturn(writerHost);
+        .thenReturn(mockTopology);
 
     final WriterFailoverHandler writerFailoverHandler = Mockito.mock(WriterFailoverHandler.class);
     final ReaderFailoverHandler readerFailoverHandler = Mockito.mock(ReaderFailoverHandler.class);
@@ -462,7 +449,7 @@ public class ClusterAwareConnectionProxyTest {
     assertTrue(proxy.isClusterTopologyAvailable());
     assertTrue(proxy.isFailoverEnabled());
     verify(mockTopologyService, never()).setClusterId(any());
-    verify(mockTopologyService, atLeastOnce()).setClusterInstanceTemplate(any());
+    verify(mockTopologyService, atLeastOnce()).setClusterInstanceHost(any());
   }
 
   @Test
@@ -485,12 +472,10 @@ public class ClusterAwareConnectionProxyTest {
     final ConnectionUrl conStr = ConnectionUrl.getConnectionUrlInstance(url, new Properties());
     final TopologyService mockTopologyService = Mockito.mock(TopologyService.class);
 
-    HostInfo writerHost = ClusterAwareTestUtils.createBasicHostInfo("writer", "test");
     final List<HostInfo> mockTopology = new ArrayList<>();
-    mockTopology.add(writerHost);
+    mockTopology.add(Mockito.mock(HostInfo.class));
     when(mockTopologyService.getTopology(eq(mockConn), any(Boolean.class)))
         .thenReturn(mockTopology);
-    when(mockTopologyService.getHostByName(mockConn)).thenReturn(writerHost);
 
     final WriterFailoverHandler writerFailoverHandler = Mockito.mock(WriterFailoverHandler.class);
     final ReaderFailoverHandler readerFailoverHandler = Mockito.mock(ReaderFailoverHandler.class);
@@ -508,7 +493,7 @@ public class ClusterAwareConnectionProxyTest {
     assertTrue(proxy.isClusterTopologyAvailable());
     assertTrue(proxy.isFailoverEnabled());
     verify(mockTopologyService, never()).setClusterId(any());
-    verify(mockTopologyService, atLeastOnce()).setClusterInstanceTemplate(any());
+    verify(mockTopologyService, atLeastOnce()).setClusterInstanceHost(any());
   }
 
   @Test
@@ -533,12 +518,10 @@ public class ClusterAwareConnectionProxyTest {
     final ConnectionUrl conStr = ConnectionUrl.getConnectionUrlInstance(url, new Properties());
     final TopologyService mockTopologyService = Mockito.mock(TopologyService.class);
 
-    HostInfo writerHost = ClusterAwareTestUtils.createBasicHostInfo("writer", "test");
     final List<HostInfo> mockTopology = new ArrayList<>();
-    mockTopology.add(writerHost);
+    mockTopology.add(Mockito.mock(HostInfo.class));
     when(mockTopologyService.getTopology(eq(mockConn), any(Boolean.class)))
-            .thenReturn(mockTopology);
-    when(mockTopologyService.getHostByName(mockConn)).thenReturn(writerHost);
+        .thenReturn(mockTopology);
 
     final WriterFailoverHandler writerFailoverHandler = Mockito.mock(WriterFailoverHandler.class);
     final ReaderFailoverHandler readerFailoverHandler = Mockito.mock(ReaderFailoverHandler.class);
@@ -556,7 +539,7 @@ public class ClusterAwareConnectionProxyTest {
     assertTrue(proxy.isClusterTopologyAvailable());
     assertTrue(proxy.isFailoverEnabled());
     verify(mockTopologyService, atLeastOnce()).setClusterId("test-cluster-id");
-    verify(mockTopologyService, atLeastOnce()).setClusterInstanceTemplate(any());
+    verify(mockTopologyService, atLeastOnce()).setClusterInstanceHost(any());
   }
 
   @Test
@@ -576,12 +559,10 @@ public class ClusterAwareConnectionProxyTest {
     final ConnectionUrl conStr = ConnectionUrl.getConnectionUrlInstance(url, new Properties());
     final TopologyService mockTopologyService = Mockito.mock(TopologyService.class);
 
-    HostInfo writerHost = ClusterAwareTestUtils.createBasicHostInfo("writer", "test");
     final List<HostInfo> mockTopology = new ArrayList<>();
-    mockTopology.add(writerHost);
+    mockTopology.add(Mockito.mock(HostInfo.class));
     when(mockTopologyService.getTopology(eq(mockConn), any(Boolean.class)))
-            .thenReturn(mockTopology);
-    when(mockTopologyService.getHostByName(mockConn)).thenReturn(writerHost);
+        .thenReturn(mockTopology);
 
     final WriterFailoverHandler writerFailoverHandler = Mockito.mock(WriterFailoverHandler.class);
     final ReaderFailoverHandler readerFailoverHandler = Mockito.mock(ReaderFailoverHandler.class);
@@ -646,9 +627,9 @@ public class ClusterAwareConnectionProxyTest {
     final ConnectionUrl conStr = ConnectionUrl.getConnectionUrlInstance(url, new Properties());
     final TopologyService mockTopologyService = Mockito.mock(TopologyService.class);
 
-    final HostInfo writerHost = ClusterAwareTestUtils.createBasicHostInfo("writer-host", "test");
-    final HostInfo readerA_Host = ClusterAwareTestUtils.createBasicHostInfo("reader-a-host", "test");
-    final HostInfo readerB_Host = ClusterAwareTestUtils.createBasicHostInfo("reader-b-host", "test");
+    final HostInfo writerHost = createBasicHostInfo("writer-host");
+    final HostInfo readerA_Host = createBasicHostInfo("reader-a-host");
+    final HostInfo readerB_Host = createBasicHostInfo("reader-b-host");
     final List<HostInfo> topology = new ArrayList<>();
     topology.add(writerHost);
     topology.add(readerA_Host);
@@ -657,7 +638,7 @@ public class ClusterAwareConnectionProxyTest {
     when(mockTopologyService.getCachedTopology()).thenReturn(topology);
     when(mockTopologyService.getTopology(eq(mockConn), any(Boolean.class))).thenReturn(topology);
     when(mockTopologyService.getHostByName(mockConn)).thenReturn(writerHost);
-    when(mockConnectionProvider.connect(refEq(writerHost))).thenReturn(mockConn);
+    when(mockConnectionProvider.connect(writerHost)).thenReturn(mockConn);
 
     final ClusterAwareConnectionProxy proxy =
         new ClusterAwareConnectionProxy(
@@ -672,6 +653,11 @@ public class ClusterAwareConnectionProxyTest {
     assertFalse(proxy.isCurrentConnectionReadOnly());
   }
 
+  private HostInfo createBasicHostInfo(String instanceName) {
+    final Map<String, String> properties = new HashMap<>();
+    return new HostInfo(null, instanceName, 1234, null, null, properties);
+  }
+
   @Test
   public void testReadOnlyTrueWhenReaderCluster() throws SQLException {
     final ConnectionImpl mockConn = Mockito.mock(ConnectionImpl.class);
@@ -684,14 +670,14 @@ public class ClusterAwareConnectionProxyTest {
     final TopologyService mockTopologyService = Mockito.mock(TopologyService.class);
     final int connectionHostIndex = 1;
 
-    final HostInfo writerHost = ClusterAwareTestUtils.createBasicHostInfo("writer-host", "test");
-    final HostInfo readerAHost = ClusterAwareTestUtils.createBasicHostInfo("reader-a-host", "test");
+    final HostInfo writerHost = createBasicHostInfo("writer-host");
+    final HostInfo readerAHost = createBasicHostInfo("reader-a-host");
     final List<HostInfo> topology = new ArrayList<>();
     topology.add(writerHost);
     topology.add(readerAHost);
 
     final ConnectionProvider mockConnectionProvider = Mockito.mock(ConnectionProvider.class);
-    when(mockConnectionProvider.connect(refEq(readerAHost))).thenReturn(mockConn);
+    when(mockConnectionProvider.connect(readerAHost)).thenReturn(mockConn);
 
     when(mockTopologyService.getTopology(eq(mockConn), any(Boolean.class))).thenReturn(topology);
     when(mockTopologyService.getCachedTopology()).thenReturn(topology);
@@ -722,16 +708,16 @@ public class ClusterAwareConnectionProxyTest {
     final TopologyService mockTopologyService = Mockito.mock(TopologyService.class);
     final int newConnectionHostIndex = 1;
 
-    final HostInfo writerHost = ClusterAwareTestUtils.createBasicHostInfo("writer-host", "test");
-    final HostInfo readerA_Host = ClusterAwareTestUtils.createBasicHostInfo("reader-a-host", "test");
-    final HostInfo readerB_Host = ClusterAwareTestUtils.createBasicHostInfo("reader-b-host", "test");
+    final HostInfo writerHost = createBasicHostInfo("writer-host");
+    final HostInfo readerA_Host = createBasicHostInfo("reader-a-host");
+    final HostInfo readerB_Host = createBasicHostInfo("reader-b-host");
     final List<HostInfo> topology = new ArrayList<>();
     topology.add(writerHost);
     topology.add(readerA_Host);
     topology.add(readerB_Host);
 
     final ConnectionProvider mockConnectionProvider = Mockito.mock(ConnectionProvider.class);
-    when(mockConnectionProvider.connect(refEq(readerA_Host))).thenReturn(mockConn);
+    when(mockConnectionProvider.connect(readerA_Host)).thenReturn(mockConn);
 
     when(mockTopologyService.getCachedTopology()).thenReturn(topology);
     when(mockTopologyService.getLastUsedReaderHost()).thenReturn(readerA_Host);
@@ -766,16 +752,16 @@ public class ClusterAwareConnectionProxyTest {
     final ConnectionUrl conStr = ConnectionUrl.getConnectionUrlInstance(url, new Properties());
     final TopologyService mockTopologyService = Mockito.mock(TopologyService.class);
 
-    final HostInfo cachedWriterHost = ClusterAwareTestUtils.createBasicHostInfo("cached-writer-host", "test");
-    final HostInfo readerA_Host = ClusterAwareTestUtils.createBasicHostInfo("reader-a-host", "test");
-    final HostInfo readerB_Host = ClusterAwareTestUtils.createBasicHostInfo("reader-b-host", "test");
+    final HostInfo cachedWriterHost = createBasicHostInfo("cached-writer-host");
+    final HostInfo readerA_Host = createBasicHostInfo("reader-a-host");
+    final HostInfo readerB_Host = createBasicHostInfo("reader-b-host");
     final List<HostInfo> cachedTopology = new ArrayList<>();
     cachedTopology.add(cachedWriterHost);
     cachedTopology.add(readerA_Host);
     cachedTopology.add(readerB_Host);
 
-    final HostInfo actualWriterHost = ClusterAwareTestUtils.createBasicHostInfo("actual-writer-host", "test");
-    final HostInfo obsoleteWriterHost = ClusterAwareTestUtils.createBasicHostInfo("obsolete-writer-host", "test");
+    final HostInfo actualWriterHost = createBasicHostInfo("actual-writer-host");
+    final HostInfo obsoleteWriterHost = createBasicHostInfo("obsolete-writer-host");
     final List<HostInfo> actualTopology = new ArrayList<>();
     actualTopology.add(actualWriterHost);
     actualTopology.add(readerA_Host);
@@ -787,8 +773,8 @@ public class ClusterAwareConnectionProxyTest {
     when(mockTopologyService.getHostByName(mockCachedWriterConn)).thenReturn(obsoleteWriterHost);
 
     ConnectionProvider mockConnectionProvider = Mockito.mock(ConnectionProvider.class);
-    when(mockConnectionProvider.connect(refEq(cachedWriterHost))).thenReturn(mockCachedWriterConn);
-    when(mockConnectionProvider.connect(refEq(actualWriterHost))).thenReturn(mockActualWriterConn);
+    when(mockConnectionProvider.connect(cachedWriterHost)).thenReturn(mockCachedWriterConn);
+    when(mockConnectionProvider.connect(actualWriterHost)).thenReturn(mockActualWriterConn);
 
     final ClusterAwareConnectionProxy proxy =
         new ClusterAwareConnectionProxy(
@@ -823,9 +809,9 @@ public class ClusterAwareConnectionProxyTest {
     final ConnectionUrl conStr = ConnectionUrl.getConnectionUrlInstance(url, new Properties());
     final TopologyService mockTopologyService = Mockito.mock(TopologyService.class);
 
-    final HostInfo writerHost = ClusterAwareTestUtils.createBasicHostInfo("writer-host", null);
-    final HostInfo readerAHost = ClusterAwareTestUtils.createBasicHostInfo("reader-a-host", null);
-    final HostInfo readerBHost = ClusterAwareTestUtils.createBasicHostInfo("reader-b-host", null);
+    final HostInfo writerHost = createBasicHostInfo("writer-host");
+    final HostInfo readerAHost = createBasicHostInfo("reader-a-host");
+    final HostInfo readerBHost = createBasicHostInfo("reader-b-host");
     final List<HostInfo> topology = new ArrayList<>();
     topology.add(writerHost);
     topology.add(readerAHost);
@@ -838,7 +824,7 @@ public class ClusterAwareConnectionProxyTest {
 
     final ConnectionProvider mockConnectionProvider = Mockito.mock(ConnectionProvider.class);
     when(mockConnectionProvider.connect(conStr.getMainHost())).thenReturn(mockDirectReaderConn);
-    when(mockConnectionProvider.connect(refEq(writerHost))).thenReturn(mockWriterConn);
+    when(mockConnectionProvider.connect(writerHost)).thenReturn(mockWriterConn);
 
     final ClusterAwareConnectionProxy proxy =
         new ClusterAwareConnectionProxy(
@@ -866,9 +852,9 @@ public class ClusterAwareConnectionProxyTest {
     final ConnectionUrl conStr = ConnectionUrl.getConnectionUrlInstance(url, new Properties());
     final TopologyService mockTopologyService = Mockito.mock(TopologyService.class);
 
-    final HostInfo writerHost = ClusterAwareTestUtils.createBasicHostInfo("writer-host", "test");
-    final HostInfo readerA_Host = ClusterAwareTestUtils.createBasicHostInfo("reader-a-host", "test");
-    final HostInfo readerB_Host = ClusterAwareTestUtils.createBasicHostInfo("reader-b-host", "test");
+    final HostInfo writerHost = createBasicHostInfo("writer-host");
+    final HostInfo readerA_Host = createBasicHostInfo("reader-a-host");
+    final HostInfo readerB_Host = createBasicHostInfo("reader-b-host");
     final List<HostInfo> topology = new ArrayList<>();
     topology.add(writerHost);
     topology.add(readerA_Host);
@@ -880,7 +866,7 @@ public class ClusterAwareConnectionProxyTest {
 
     final ConnectionProvider mockConnectionProvider = Mockito.mock(ConnectionProvider.class);
     when(mockConnectionProvider.connect(conStr.getMainHost())).thenReturn(mockReaderConnection);
-    when(mockConnectionProvider.connect(refEq(writerHost))).thenReturn(mockWriterConnection);
+    when(mockConnectionProvider.connect(writerHost)).thenReturn(mockWriterConnection);
 
     final ClusterAwareConnectionProxy proxy =
         new ClusterAwareConnectionProxy(
diff --git a/src/test/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareReaderFailoverHandlerTest.java b/src/test/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareReaderFailoverHandlerTest.java
index a7c6ea3..a752bd9 100644
--- a/src/test/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareReaderFailoverHandlerTest.java
+++ b/src/test/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareReaderFailoverHandlerTest.java
@@ -30,8 +30,8 @@
 
 package com.mysql.cj.jdbc.ha.ca;
 
+import com.mysql.cj.conf.ConnectionUrl;
 import com.mysql.cj.conf.HostInfo;
-import com.mysql.cj.conf.PropertyKey;
 import com.mysql.cj.jdbc.ConnectionImpl;
 import com.mysql.cj.log.Log;
 import org.junit.jupiter.api.Test;
@@ -41,10 +41,9 @@ import org.mockito.stubbing.Answer;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
-import java.util.Map;
+import java.util.Properties;
 import java.util.Set;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
@@ -53,7 +52,6 @@ import static org.junit.jupiter.api.Assertions.assertNull;
 import static org.junit.jupiter.api.Assertions.assertSame;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.refEq;
 import static org.mockito.Mockito.atLeast;
 import static org.mockito.Mockito.atLeastOnce;
 import static org.mockito.Mockito.eq;
@@ -66,29 +64,13 @@ import static org.mockito.Mockito.when;
  * ClusterAwareReaderFailoverHandlerTest class.
  * */
 public class ClusterAwareReaderFailoverHandlerTest {
-  static final List<HostInfo> testHosts;
-  static {
-    testHosts = new ArrayList<>();
-    List<String> instances = Arrays.asList(
-            "writer-1",
-            "reader-1",
-            "reader-2",
-            "reader-3",
-            "reader-4",
-            "reader-5"
-    );
-    for(String instance : instances) {
-      HostInfo host = ClusterAwareTestUtils.createBasicHostInfo(instance, "test");
-      testHosts.add(host);
-    }
-  }
-
-  static final Map<String, String> testConnectionProps;
-  static {
-    testConnectionProps = new HashMap<>();
-    testConnectionProps.put(PropertyKey.DBNAME.getKeyName(), "test");
-  }
-
+  static final int numTestUrls = 6;
+  static final String testUrl1 = "jdbc:mysql:aws://writer-1:1234/";
+  static final String testUrl2 = "jdbc:mysql:aws://reader-1:2345/";
+  static final String testUrl3 = "jdbc:mysql:aws://reader-2:3456/";
+  static final String testUrl4 = "jdbc:mysql:aws://reader-3:4567/";
+  static final String testUrl5 = "jdbc:mysql:aws://reader-4:5678/";
+  static final String testUrl6 = "jdbc:mysql:aws://reader-5:6789/";
   final Log mockLog = Mockito.mock(Log.class);
 
   @Test
@@ -106,9 +88,9 @@ public class ClusterAwareReaderFailoverHandlerTest {
     final int successHostIndex = 4;
     for (int i = 0; i < hosts.size(); i++) {
       if (i != successHostIndex) {
-        when(mockConnProvider.connect(refEq(hosts.get(i)))).thenThrow(new SQLException());
+        when(mockConnProvider.connect(hosts.get(i))).thenThrow(new SQLException());
       } else {
-        when(mockConnProvider.connect(refEq(hosts.get(i)))).thenReturn(mockConnection);
+        when(mockConnProvider.connect(hosts.get(i))).thenReturn(mockConnection);
       }
     }
 
@@ -120,10 +102,10 @@ public class ClusterAwareReaderFailoverHandlerTest {
     when(mockTopologyService.getDownHosts()).thenReturn(downHosts);
 
     final ReaderFailoverHandler target =
-        new ClusterAwareReaderFailoverHandler(mockTopologyService, mockConnProvider, testConnectionProps, mockLog);
-    final ReaderFailoverResult result = target.failover(hosts, hosts.get(currentHostIndex));
+        new ClusterAwareReaderFailoverHandler(mockTopologyService, mockConnProvider, mockLog);
+    final ConnectionAttemptResult result = target.failover(hosts, hosts.get(currentHostIndex));
 
-    assertTrue(result.isConnected());
+    assertTrue(result.isSuccess());
     assertSame(mockConnection, result.getConnection());
     assertEquals(successHostIndex, result.getConnectionIndex());
 
@@ -134,12 +116,16 @@ public class ClusterAwareReaderFailoverHandlerTest {
   }
 
   private List<HostInfo> getHostsFromTestUrls(int numHosts) {
+    final List<String> urlList =
+        Arrays.asList(testUrl1, testUrl2, testUrl3, testUrl4, testUrl5, testUrl6);
     final List<HostInfo> hosts = new ArrayList<>();
-    if (numHosts < 0 || numHosts > testHosts.size()) {
-      numHosts = testHosts.size();
+    if (numHosts < 0 || numHosts > numTestUrls) {
+      numHosts = numTestUrls;
     }
     for (int i = 0; i < numHosts; i++) {
-      hosts.add(testHosts.get(i));
+      ConnectionUrl connUrl =
+          ConnectionUrl.getConnectionUrlInstance(urlList.get(i), new Properties());
+      hosts.add(connUrl.getMainHost());
     }
     return hosts;
   }
@@ -156,12 +142,14 @@ public class ClusterAwareReaderFailoverHandlerTest {
     final ConnectionImpl mockConnection = Mockito.mock(ConnectionImpl.class);
     final List<HostInfo> hosts = getHostsFromTestUrls(6);
     final int currentHostIndex = 2;
-    for (HostInfo host : hosts) {
-      when(mockConnProvider.connect(refEq(host)))
-              .thenAnswer((Answer<ConnectionImpl>) invocation -> {
-                Thread.sleep(20000);
-                return mockConnection;
-              });
+    for (int i = 0; i < hosts.size(); i++) {
+        when(mockConnProvider.connect(hosts.get(i)))
+                .thenAnswer(
+                        (Answer<ConnectionImpl>)
+                                invocation -> {
+                                  Thread.sleep(20000);
+                                  return mockConnection;
+                                });
     }
 
     final Set<String> downHosts = new HashSet<>();
@@ -172,10 +160,10 @@ public class ClusterAwareReaderFailoverHandlerTest {
     when(mockTopologyService.getDownHosts()).thenReturn(downHosts);
 
     final ReaderFailoverHandler target =
-            new ClusterAwareReaderFailoverHandler(mockTopologyService, mockConnProvider, testConnectionProps, 5000, 30000, mockLog);
-    final ReaderFailoverResult result = target.failover(hosts, hosts.get(currentHostIndex));
+            new ClusterAwareReaderFailoverHandler(mockTopologyService, mockConnProvider, 5000, 30000, mockLog);
+    final ConnectionAttemptResult result = target.failover(hosts, hosts.get(currentHostIndex));
 
-    assertFalse(result.isConnected());
+    assertFalse(result.isSuccess());
     assertNull(result.getConnection());
     assertEquals(ClusterAwareConnectionProxy.NO_CONNECTION_INDEX, result.getConnectionIndex());
   }
@@ -185,22 +173,22 @@ public class ClusterAwareReaderFailoverHandlerTest {
     final TopologyService mockTopologyService = Mockito.mock(TopologyService.class);
     final ClusterAwareReaderFailoverHandler target =
         new ClusterAwareReaderFailoverHandler(
-            mockTopologyService, Mockito.mock(ConnectionProvider.class), testConnectionProps, mockLog);
+            mockTopologyService, Mockito.mock(ConnectionProvider.class), mockLog);
     final HostInfo currentHost = new HostInfo(null, "writer", 1234, null, null);
 
-    ReaderFailoverResult result = target.failover(null, currentHost);
-    assertFalse(result.isConnected());
+    ConnectionAttemptResult result = target.failover(null, currentHost);
+    assertFalse(result.isSuccess());
     assertNull(result.getConnection());
     assertEquals(ClusterAwareConnectionProxy.NO_CONNECTION_INDEX, result.getConnectionIndex());
-    verify(mockTopologyService, atLeast(1)).addToDownHostList(eq(currentHost));
+    verify(mockTopologyService, times(1)).addToDownHostList(eq(currentHost));
 
     final List<HostInfo> hosts = new ArrayList<>();
     result = target.failover(hosts, currentHost);
-    assertFalse(result.isConnected());
+    assertFalse(result.isSuccess());
     assertNull(result.getConnection());
     assertEquals(ClusterAwareConnectionProxy.NO_CONNECTION_INDEX, result.getConnectionIndex());
 
-    verify(mockTopologyService, atLeast(2)).addToDownHostList(eq(currentHost));
+    verify(mockTopologyService, times(2)).addToDownHostList(eq(currentHost));
   }
 
   @Test
@@ -215,20 +203,20 @@ public class ClusterAwareReaderFailoverHandlerTest {
     final HostInfo slowHost = hosts.get(1);
     final HostInfo fastHost = hosts.get(2);
     final ConnectionProvider mockConnProvider = Mockito.mock(ConnectionProvider.class);
-    when(mockConnProvider.connect(refEq(slowHost)))
+    when(mockConnProvider.connect(slowHost))
         .thenAnswer(
             (Answer<ConnectionImpl>)
                 invocation -> {
                   Thread.sleep(20000);
                   return mockConnection;
                 });
-    when(mockConnProvider.connect(refEq(fastHost))).thenReturn(mockConnection);
+    when(mockConnProvider.connect(fastHost)).thenReturn(mockConnection);
 
     final ReaderFailoverHandler target =
-        new ClusterAwareReaderFailoverHandler(mockTopologyService, mockConnProvider, testConnectionProps, mockLog);
-    final ReaderFailoverResult result = target.getReaderConnection(hosts);
+        new ClusterAwareReaderFailoverHandler(mockTopologyService, mockConnProvider, mockLog);
+    final ConnectionAttemptResult result = target.getReaderConnection(hosts);
 
-    assertTrue(result.isConnected());
+    assertTrue(result.isSuccess());
     assertSame(mockConnection, result.getConnection());
     assertEquals(2, result.getConnectionIndex());
 
@@ -250,10 +238,10 @@ public class ClusterAwareReaderFailoverHandlerTest {
     final int currentHostIndex = 2;
 
     final ReaderFailoverHandler target =
-        new ClusterAwareReaderFailoverHandler(mockTopologyService, mockConnProvider, testConnectionProps, mockLog);
-    final ReaderFailoverResult result = target.getReaderConnection(hosts);
+        new ClusterAwareReaderFailoverHandler(mockTopologyService, mockConnProvider, mockLog);
+    final ConnectionAttemptResult result = target.getReaderConnection(hosts);
 
-    assertFalse(result.isConnected());
+    assertFalse(result.isSuccess());
     assertNull(result.getConnection());
     assertEquals(ClusterAwareConnectionProxy.NO_CONNECTION_INDEX, result.getConnectionIndex());
 
@@ -287,10 +275,10 @@ public class ClusterAwareReaderFailoverHandlerTest {
                 });
 
     final ClusterAwareReaderFailoverHandler target =
-        new ClusterAwareReaderFailoverHandler(mockTopologyService, mockProvider, testConnectionProps, 60000, 1000, mockLog);
-    final ReaderFailoverResult result = target.getReaderConnection(hosts);
+        new ClusterAwareReaderFailoverHandler(mockTopologyService, mockProvider, 60000, 1000, mockLog);
+    final ConnectionAttemptResult result = target.getReaderConnection(hosts);
 
-    assertFalse(result.isConnected());
+    assertFalse(result.isSuccess());
     assertNull(result.getConnection());
     assertEquals(ClusterAwareConnectionProxy.NO_CONNECTION_INDEX, result.getConnectionIndex());
 
@@ -309,7 +297,7 @@ public class ClusterAwareReaderFailoverHandlerTest {
 
     final ClusterAwareReaderFailoverHandler target =
         new ClusterAwareReaderFailoverHandler(
-            Mockito.mock(TopologyService.class), Mockito.mock(ConnectionProvider.class), testConnectionProps, mockLog);
+            Mockito.mock(TopologyService.class), Mockito.mock(ConnectionProvider.class), mockLog);
     final List<ClusterAwareReaderFailoverHandler.HostTuple> tuplesByPriority =
         target.getHostTuplesByPriority(originalHosts, downHosts);
 
@@ -356,7 +344,7 @@ public class ClusterAwareReaderFailoverHandlerTest {
 
     final ClusterAwareReaderFailoverHandler target =
         new ClusterAwareReaderFailoverHandler(
-            Mockito.mock(TopologyService.class), Mockito.mock(ConnectionProvider.class), testConnectionProps, mockLog);
+            Mockito.mock(TopologyService.class), Mockito.mock(ConnectionProvider.class), mockLog);
     final List<ClusterAwareReaderFailoverHandler.HostTuple> readerTuples =
         target.getReaderTuplesByPriority(originalHosts, downHosts);
 
diff --git a/src/test/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareTestUtils.java b/src/test/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareTestUtils.java
deleted file mode 100644
index 98118fa..0000000
--- a/src/test/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareTestUtils.java
+++ /dev/null
@@ -1,22 +0,0 @@
-package com.mysql.cj.jdbc.ha.ca;
-
-import com.mysql.cj.conf.ConnectionUrl;
-import com.mysql.cj.conf.HostInfo;
-import com.mysql.cj.conf.PropertyKey;
-
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Properties;
-
-public class ClusterAwareTestUtils {
-    protected static HostInfo createBasicHostInfo(String instanceName, String db) {
-        final Map<String, String> properties = new HashMap<>();
-        properties.put(TopologyServicePropertyKeys.INSTANCE_NAME, instanceName);
-        String url = "jdbc:mysql:aws://" + instanceName + ".com:1234/";
-        db = db == null ? "" : db;
-        properties.put(PropertyKey.DBNAME.getKeyName(), db);
-        url += db;
-        final ConnectionUrl conStr = ConnectionUrl.getConnectionUrlInstance(url, new Properties());
-        return new HostInfo(conStr, instanceName, 1234, null, null, properties);
-    }
-}
diff --git a/src/test/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareWriterFailoverHandlerTest.java b/src/test/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareWriterFailoverHandlerTest.java
index 6d0120c..c7b82ac 100644
--- a/src/test/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareWriterFailoverHandlerTest.java
+++ b/src/test/java/com/mysql/cj/jdbc/ha/ca/ClusterAwareWriterFailoverHandlerTest.java
@@ -34,6 +34,7 @@ import com.mysql.cj.conf.HostInfo;
 import com.mysql.cj.jdbc.ConnectionImpl;
 import com.mysql.cj.jdbc.JdbcConnection;
 import com.mysql.cj.log.Log;
+import com.mysql.cj.log.StandardLogger;
 import org.junit.jupiter.api.Test;
 import org.mockito.ArgumentMatchers;
 import org.mockito.InOrder;
@@ -44,6 +45,7 @@ import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
@@ -51,7 +53,6 @@ import static org.junit.jupiter.api.Assertions.assertSame;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.eq;
-import static org.mockito.ArgumentMatchers.refEq;
 import static org.mockito.Mockito.atLeastOnce;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
@@ -61,7 +62,9 @@ import static org.mockito.Mockito.when;
  * ClusterAwareWriterFailoverHandlerTest class.
  * */
 public class ClusterAwareWriterFailoverHandlerTest {
-  final Log mockLog = Mockito.mock(Log.class);
+
+  // Log mockLog = Mockito.mock(Log.class);
+  final Log mockLog = new StandardLogger(Log.LOGGER_INSTANCE_NAME);
 
   /**
    * Verify that writer failover handler can re-connect to a current writer node.
@@ -76,17 +79,17 @@ public class ClusterAwareWriterFailoverHandlerTest {
     final ConnectionImpl mockConnection = Mockito.mock(ConnectionImpl.class);
     final ReaderFailoverHandler mockReaderFailover = Mockito.mock(ReaderFailoverHandler.class);
 
-    final HostInfo writerHost = ClusterAwareTestUtils.createBasicHostInfo("writer-host", "test");
-    final HostInfo readerA_Host = ClusterAwareTestUtils.createBasicHostInfo("reader-a-host", "test");
-    final HostInfo readerB_Host = ClusterAwareTestUtils.createBasicHostInfo("reader-b-host", "test");
+    final HostInfo writerHost = createBasicHostInfo("writer-host");
+    final HostInfo readerA_Host = createBasicHostInfo("reader-a-host");
+    final HostInfo readerB_Host = createBasicHostInfo("reader-b-host");
     final List<HostInfo> currentTopology = new ArrayList<>();
     currentTopology.add(writerHost);
     currentTopology.add(readerA_Host);
     currentTopology.add(readerB_Host);
 
-    when(mockConnectionProvider.connect(refEq(writerHost))).thenReturn(mockConnection);
-    when(mockConnectionProvider.connect(refEq(readerA_Host))).thenThrow(SQLException.class);
-    when(mockConnectionProvider.connect(refEq(readerB_Host))).thenThrow(SQLException.class);
+    when(mockConnectionProvider.connect(writerHost)).thenReturn(mockConnection);
+    when(mockConnectionProvider.connect(readerA_Host)).thenThrow(SQLException.class);
+    when(mockConnectionProvider.connect(readerB_Host)).thenThrow(SQLException.class);
 
     when(mockTopologyService.getTopology(any(JdbcConnection.class), eq(true)))
         .thenReturn(currentTopology);
@@ -99,20 +102,25 @@ public class ClusterAwareWriterFailoverHandlerTest {
             mockTopologyService,
             mockConnectionProvider,
             mockReaderFailover,
-            new HashMap<>(),
             5000,
             2000,
             2000,
             mockLog);
-    final WriterFailoverResult result = target.failover(currentTopology);
+    final ResolvedHostInfo result = target.failover(currentTopology);
 
     assertTrue(result.isConnected());
     assertFalse(result.isNewHost());
     assertSame(result.getNewConnection(), mockConnection);
 
     final InOrder inOrder = Mockito.inOrder(mockTopologyService);
-    inOrder.verify(mockTopologyService).addToDownHostList(refEq(writerHost));
-    inOrder.verify(mockTopologyService).removeFromDownHostList(refEq(writerHost));
+    inOrder.verify(mockTopologyService).addToDownHostList(eq(writerHost));
+    inOrder.verify(mockTopologyService).removeFromDownHostList(eq(writerHost));
+  }
+
+  private HostInfo createBasicHostInfo(String instanceName) {
+    final Map<String, String> properties = new HashMap<>();
+    properties.put(TopologyServicePropertyKeys.INSTANCE_NAME, instanceName);
+    return new HostInfo(null, instanceName, 1234, null, null, properties);
   }
 
   /**
@@ -131,22 +139,22 @@ public class ClusterAwareWriterFailoverHandlerTest {
     final ConnectionImpl mockReaderA_Connection = Mockito.mock(ConnectionImpl.class);
     final ReaderFailoverHandler mockReaderFailover = Mockito.mock(ReaderFailoverHandler.class);
 
-    final HostInfo writerHost = ClusterAwareTestUtils.createBasicHostInfo("writer-host", "test");
-    final HostInfo readerA_Host = ClusterAwareTestUtils.createBasicHostInfo("reader-a-host", "test");
-    final HostInfo readerB_Host = ClusterAwareTestUtils.createBasicHostInfo("reader-b-host", "test");
+    final HostInfo writerHost = createBasicHostInfo("writer-host");
+    final HostInfo readerA_Host = createBasicHostInfo("reader-a-host");
+    final HostInfo readerB_Host = createBasicHostInfo("reader-b-host");
     final List<HostInfo> currentTopology = new ArrayList<>();
     currentTopology.add(writerHost);
     currentTopology.add(readerA_Host);
     currentTopology.add(readerB_Host);
 
-    final HostInfo newWriterHost = ClusterAwareTestUtils.createBasicHostInfo("new-writer-host", "test");
+    final HostInfo newWriterHost = createBasicHostInfo("new-writer-host");
     final List<HostInfo> newTopology = new ArrayList<>();
     newTopology.add(newWriterHost);
     newTopology.add(readerA_Host);
     newTopology.add(readerB_Host);
 
-    when(mockConnectionProvider.connect(refEq(writerHost))).thenReturn(mockWriterConnection);
-    when(mockConnectionProvider.connect(refEq(readerB_Host))).thenThrow(SQLException.class);
+    when(mockConnectionProvider.connect(writerHost)).thenReturn(mockWriterConnection);
+    when(mockConnectionProvider.connect(readerB_Host)).thenThrow(SQLException.class);
 
     when(mockTopologyService.getTopology(eq(mockWriterConnection), eq(true)))
         .thenReturn(currentTopology);
@@ -155,10 +163,10 @@ public class ClusterAwareWriterFailoverHandlerTest {
 
     when(mockReaderFailover.getReaderConnection(ArgumentMatchers.anyList()))
         .thenAnswer(
-            (Answer<ReaderFailoverResult>)
+            (Answer<ConnectionAttemptResult>)
                 invocation -> {
                   Thread.sleep(5000);
-                  return new ReaderFailoverResult(mockReaderA_Connection, 1, true);
+                  return new ConnectionAttemptResult(mockReaderA_Connection, 1, true);
                 });
 
     final ClusterAwareWriterFailoverHandler target =
@@ -166,20 +174,19 @@ public class ClusterAwareWriterFailoverHandlerTest {
             mockTopologyService,
             mockConnectionProvider,
             mockReaderFailover,
-            new HashMap<>(),
             60000,
             5000,
             5000,
             mockLog);
-    final WriterFailoverResult result = target.failover(currentTopology);
+    final ResolvedHostInfo result = target.failover(currentTopology);
 
     assertTrue(result.isConnected());
     assertFalse(result.isNewHost());
     assertSame(result.getNewConnection(), mockWriterConnection);
 
     final InOrder inOrder = Mockito.inOrder(mockTopologyService);
-    inOrder.verify(mockTopologyService).addToDownHostList(refEq(writerHost));
-    inOrder.verify(mockTopologyService).removeFromDownHostList(refEq(writerHost));
+    inOrder.verify(mockTopologyService).addToDownHostList(eq(writerHost));
+    inOrder.verify(mockTopologyService).removeFromDownHostList(eq(writerHost));
   }
 
   /**
@@ -197,48 +204,47 @@ public class ClusterAwareWriterFailoverHandlerTest {
     final ConnectionImpl mockReaderA_Connection = Mockito.mock(ConnectionImpl.class);
     final ReaderFailoverHandler mockReaderFailover = Mockito.mock(ReaderFailoverHandler.class);
 
-    final HostInfo writerHost = ClusterAwareTestUtils.createBasicHostInfo("writer-host", "test");
-    final HostInfo readerA_Host = ClusterAwareTestUtils.createBasicHostInfo("reader-a-host", "test");
-    final HostInfo readerB_Host = ClusterAwareTestUtils.createBasicHostInfo("reader-b-host", "test");
+    final HostInfo writerHost = createBasicHostInfo("writer-host");
+    final HostInfo readerA_Host = createBasicHostInfo("reader-a-host");
+    final HostInfo readerB_Host = createBasicHostInfo("reader-b-host");
     final List<HostInfo> currentTopology = new ArrayList<>();
     currentTopology.add(writerHost);
     currentTopology.add(readerA_Host);
     currentTopology.add(readerB_Host);
 
-    when(mockConnectionProvider.connect(refEq(writerHost)))
+    when(mockConnectionProvider.connect(writerHost))
         .thenAnswer(
             (Answer<ConnectionImpl>)
                 invocation -> {
                   Thread.sleep(5000);
                   return mockWriterConnection;
                 });
-    when(mockConnectionProvider.connect(refEq(readerB_Host))).thenThrow(SQLException.class);
+    when(mockConnectionProvider.connect(readerB_Host)).thenThrow(SQLException.class);
 
     when(mockTopologyService.getTopology(any(JdbcConnection.class), eq(true)))
         .thenReturn(currentTopology);
 
     when(mockReaderFailover.getReaderConnection(ArgumentMatchers.anyList()))
-        .thenReturn(new ReaderFailoverResult(mockReaderA_Connection, 1, true));
+        .thenReturn(new ConnectionAttemptResult(mockReaderA_Connection, 1, true));
 
     final ClusterAwareWriterFailoverHandler target =
         new ClusterAwareWriterFailoverHandler(
             mockTopologyService,
             mockConnectionProvider,
             mockReaderFailover,
-            new HashMap<>(),
             60000,
             2000,
             2000,
             mockLog);
-    final WriterFailoverResult result = target.failover(currentTopology);
+    final ResolvedHostInfo result = target.failover(currentTopology);
 
     assertTrue(result.isConnected());
     assertFalse(result.isNewHost());
     assertSame(result.getNewConnection(), mockWriterConnection);
 
     final InOrder inOrder = Mockito.inOrder(mockTopologyService);
-    inOrder.verify(mockTopologyService).addToDownHostList(refEq(writerHost));
-    inOrder.verify(mockTopologyService).removeFromDownHostList(refEq(writerHost));
+    inOrder.verify(mockTopologyService).addToDownHostList(eq(writerHost));
+    inOrder.verify(mockTopologyService).removeFromDownHostList(eq(writerHost));
   }
 
   /**
@@ -259,30 +265,30 @@ public class ClusterAwareWriterFailoverHandlerTest {
     final ConnectionImpl mockReaderB_Connection = Mockito.mock(ConnectionImpl.class);
     final ReaderFailoverHandler mockReaderFailover = Mockito.mock(ReaderFailoverHandler.class);
 
-    final HostInfo writerHost = ClusterAwareTestUtils.createBasicHostInfo("writer-host", "test");
-    final HostInfo readerA_Host = ClusterAwareTestUtils.createBasicHostInfo("reader-a-host", "test");
-    final HostInfo readerB_Host = ClusterAwareTestUtils.createBasicHostInfo("reader-b-host", "test");
+    final HostInfo writerHost = createBasicHostInfo("writer-host");
+    final HostInfo readerA_Host = createBasicHostInfo("reader-a-host");
+    final HostInfo readerB_Host = createBasicHostInfo("reader-b-host");
     final List<HostInfo> currentTopology = new ArrayList<>();
     currentTopology.add(writerHost);
     currentTopology.add(readerA_Host);
     currentTopology.add(readerB_Host);
 
-    final HostInfo newWriterHost = ClusterAwareTestUtils.createBasicHostInfo("new-writer-host", "test");
+    final HostInfo newWriterHost = createBasicHostInfo("new-writer-host");
     final List<HostInfo> newTopology = new ArrayList<>();
     newTopology.add(newWriterHost);
     newTopology.add(readerA_Host);
     newTopology.add(readerB_Host);
 
-    when(mockConnectionProvider.connect(refEq(writerHost)))
+    when(mockConnectionProvider.connect(writerHost))
         .thenAnswer(
             (Answer<ConnectionImpl>)
                 invocation -> {
                   Thread.sleep(5000);
                   return mockWriterConnection;
                 });
-    when(mockConnectionProvider.connect(refEq(readerA_Host))).thenReturn(mockReaderA_Connection);
-    when(mockConnectionProvider.connect(refEq(readerB_Host))).thenReturn(mockReaderB_Connection);
-    when(mockConnectionProvider.connect(refEq(newWriterHost))).thenReturn(mockNewWriterConnection);
+    when(mockConnectionProvider.connect(readerA_Host)).thenReturn(mockReaderA_Connection);
+    when(mockConnectionProvider.connect(readerB_Host)).thenReturn(mockReaderB_Connection);
+    when(mockConnectionProvider.connect(newWriterHost)).thenReturn(mockNewWriterConnection);
 
     when(mockTopologyService.getTopology(eq(mockWriterConnection), eq(true)))
         .thenReturn(currentTopology);
@@ -290,19 +296,18 @@ public class ClusterAwareWriterFailoverHandlerTest {
         .thenReturn(newTopology);
 
     when(mockReaderFailover.getReaderConnection(ArgumentMatchers.anyList()))
-        .thenReturn(new ReaderFailoverResult(mockReaderA_Connection, 1, true));
+        .thenReturn(new ConnectionAttemptResult(mockReaderA_Connection, 1, true));
 
     final ClusterAwareWriterFailoverHandler target =
         new ClusterAwareWriterFailoverHandler(
             mockTopologyService,
             mockConnectionProvider,
             mockReaderFailover,
-            new HashMap<>(),
             60000,
             5000,
             5000,
             mockLog);
-    final WriterFailoverResult result = target.failover(currentTopology);
+    final ResolvedHostInfo result = target.failover(currentTopology);
 
     assertTrue(result.isConnected());
     assertTrue(result.isNewHost());
@@ -310,8 +315,8 @@ public class ClusterAwareWriterFailoverHandlerTest {
     assertEquals(3, result.getTopology().size());
     assertEquals("new-writer-host", result.getTopology().get(0).getHost());
 
-    verify(mockTopologyService, times(1)).addToDownHostList(refEq(writerHost));
-    verify(mockTopologyService, times(1)).removeFromDownHostList(refEq(newWriterHost));
+    verify(mockTopologyService, times(1)).addToDownHostList(eq(writerHost));
+    verify(mockTopologyService, times(1)).removeFromDownHostList(eq(newWriterHost));
   }
 
   /**
@@ -330,15 +335,15 @@ public class ClusterAwareWriterFailoverHandlerTest {
     final ConnectionImpl mockReaderB_Connection = Mockito.mock(ConnectionImpl.class);
     final ReaderFailoverHandler mockReaderFailover = Mockito.mock(ReaderFailoverHandler.class);
 
-    final HostInfo initialWriterHost = ClusterAwareTestUtils.createBasicHostInfo("initial-writer-host", "test");
-    final HostInfo readerA_Host = ClusterAwareTestUtils.createBasicHostInfo("reader-a-host", "test");
-    final HostInfo readerB_Host = ClusterAwareTestUtils.createBasicHostInfo("reader-b-host", "test");
+    final HostInfo initialWriterHost = createBasicHostInfo("initial-writer-host");
+    final HostInfo readerA_Host = createBasicHostInfo("reader-a-host");
+    final HostInfo readerB_Host = createBasicHostInfo("reader-b-host");
     final List<HostInfo> currentTopology = new ArrayList<>();
     currentTopology.add(initialWriterHost);
     currentTopology.add(readerA_Host);
     currentTopology.add(readerB_Host);
 
-    final HostInfo newWriterHost = ClusterAwareTestUtils.createBasicHostInfo("new-writer-host", "test");
+    final HostInfo newWriterHost = createBasicHostInfo("new-writer-host");
     final List<HostInfo> newTopology = new ArrayList<>();
     newTopology.add(newWriterHost);
     newTopology.add(initialWriterHost);
@@ -347,9 +352,9 @@ public class ClusterAwareWriterFailoverHandlerTest {
 
     when(mockConnectionProvider.connect(initialWriterHost))
         .thenReturn(Mockito.mock(ConnectionImpl.class));
-    when(mockConnectionProvider.connect(refEq(readerA_Host))).thenReturn(mockReaderA_Connection);
-    when(mockConnectionProvider.connect(refEq(readerB_Host))).thenReturn(mockReaderB_Connection);
-    when(mockConnectionProvider.connect(refEq(newWriterHost)))
+    when(mockConnectionProvider.connect(readerA_Host)).thenReturn(mockReaderA_Connection);
+    when(mockConnectionProvider.connect(readerB_Host)).thenReturn(mockReaderB_Connection);
+    when(mockConnectionProvider.connect(newWriterHost))
         .thenAnswer(
             (Answer<ConnectionImpl>)
                 invocation -> {
@@ -361,19 +366,18 @@ public class ClusterAwareWriterFailoverHandlerTest {
         .thenReturn(newTopology);
 
     when(mockReaderFailover.getReaderConnection(ArgumentMatchers.anyList()))
-        .thenReturn(new ReaderFailoverResult(mockReaderA_Connection, 1, true));
+        .thenReturn(new ConnectionAttemptResult(mockReaderA_Connection, 1, true));
 
     final ClusterAwareWriterFailoverHandler target =
         new ClusterAwareWriterFailoverHandler(
             mockTopologyService,
             mockConnectionProvider,
             mockReaderFailover,
-            new HashMap<>(),
             60000,
             5000,
             5000,
             mockLog);
-    final WriterFailoverResult result = target.failover(currentTopology);
+    final ResolvedHostInfo result = target.failover(currentTopology);
 
     assertTrue(result.isConnected());
     assertTrue(result.isNewHost());
@@ -381,8 +385,8 @@ public class ClusterAwareWriterFailoverHandlerTest {
     assertEquals(4, result.getTopology().size());
     assertEquals("new-writer-host", result.getTopology().get(0).getHost());
 
-    verify(mockTopologyService, times(1)).addToDownHostList(refEq(initialWriterHost));
-    verify(mockTopologyService, times(1)).removeFromDownHostList(refEq(newWriterHost));
+    verify(mockTopologyService, times(1)).addToDownHostList(eq(initialWriterHost));
+    verify(mockTopologyService, times(1)).removeFromDownHostList(eq(newWriterHost));
   }
 
   /**
@@ -403,30 +407,30 @@ public class ClusterAwareWriterFailoverHandlerTest {
     final ConnectionImpl mockReaderB_Connection = Mockito.mock(ConnectionImpl.class);
     final ReaderFailoverHandler mockReaderFailover = Mockito.mock(ReaderFailoverHandler.class);
 
-    final HostInfo writerHost = ClusterAwareTestUtils.createBasicHostInfo("writer-host", "test");
-    final HostInfo readerA_Host = ClusterAwareTestUtils.createBasicHostInfo("reader-a-host", "test");
-    final HostInfo readerB_Host = ClusterAwareTestUtils.createBasicHostInfo("reader-b-host", "test");
+    final HostInfo writerHost = createBasicHostInfo("writer-host");
+    final HostInfo readerA_Host = createBasicHostInfo("reader-a-host");
+    final HostInfo readerB_Host = createBasicHostInfo("reader-b-host");
     final List<HostInfo> currentTopology = new ArrayList<>();
     currentTopology.add(writerHost);
     currentTopology.add(readerA_Host);
     currentTopology.add(readerB_Host);
 
-    final HostInfo newWriterHost = ClusterAwareTestUtils.createBasicHostInfo("new-writer-host", "test");
+    final HostInfo newWriterHost = createBasicHostInfo("new-writer-host");
     final List<HostInfo> newTopology = new ArrayList<>();
     newTopology.add(newWriterHost);
     newTopology.add(readerA_Host);
     newTopology.add(readerB_Host);
 
-    when(mockConnectionProvider.connect(refEq(writerHost)))
+    when(mockConnectionProvider.connect(writerHost))
         .thenAnswer(
             (Answer<ConnectionImpl>)
                 invocation -> {
                   Thread.sleep(30000);
                   return mockWriterConnection;
                 });
-    when(mockConnectionProvider.connect(refEq(readerA_Host))).thenReturn(mockReaderA_Connection);
-    when(mockConnectionProvider.connect(refEq(readerB_Host))).thenReturn(mockReaderB_Connection);
-    when(mockConnectionProvider.connect(refEq(newWriterHost)))
+    when(mockConnectionProvider.connect(readerA_Host)).thenReturn(mockReaderA_Connection);
+    when(mockConnectionProvider.connect(readerB_Host)).thenReturn(mockReaderB_Connection);
+    when(mockConnectionProvider.connect(newWriterHost))
         .thenAnswer(
             (Answer<ConnectionImpl>)
                 invocation -> {
@@ -440,24 +444,23 @@ public class ClusterAwareWriterFailoverHandlerTest {
         .thenReturn(newTopology);
 
     when(mockReaderFailover.getReaderConnection(ArgumentMatchers.anyList()))
-        .thenReturn(new ReaderFailoverResult(mockReaderA_Connection, 1, true));
+        .thenReturn(new ConnectionAttemptResult(mockReaderA_Connection, 1, true));
 
     final ClusterAwareWriterFailoverHandler target =
         new ClusterAwareWriterFailoverHandler(
             mockTopologyService,
             mockConnectionProvider,
             mockReaderFailover,
-            new HashMap<>(),
             5000,
             2000,
             2000,
             mockLog);
-    final WriterFailoverResult result = target.failover(currentTopology);
+    final ResolvedHostInfo result = target.failover(currentTopology);
 
     assertFalse(result.isConnected());
     assertFalse(result.isNewHost());
 
-    verify(mockTopologyService, times(1)).addToDownHostList(refEq(writerHost));
+    verify(mockTopologyService, times(1)).addToDownHostList(eq(writerHost));
   }
 
   /**
@@ -475,47 +478,46 @@ public class ClusterAwareWriterFailoverHandlerTest {
     final ConnectionImpl mockReaderB_Connection = Mockito.mock(ConnectionImpl.class);
     final ReaderFailoverHandler mockReaderFailover = Mockito.mock(ReaderFailoverHandler.class);
 
-    final HostInfo writerHost = ClusterAwareTestUtils.createBasicHostInfo("writer-host", "test");
-    final HostInfo readerA_Host = ClusterAwareTestUtils.createBasicHostInfo("reader-a-host", "test");
-    final HostInfo readerB_Host = ClusterAwareTestUtils.createBasicHostInfo("reader-b-host", "test");
+    final HostInfo writerHost = createBasicHostInfo("writer-host");
+    final HostInfo readerA_Host = createBasicHostInfo("reader-a-host");
+    final HostInfo readerB_Host = createBasicHostInfo("reader-b-host");
     final List<HostInfo> currentTopology = new ArrayList<>();
     currentTopology.add(writerHost);
     currentTopology.add(readerA_Host);
     currentTopology.add(readerB_Host);
 
-    final HostInfo newWriterHost = ClusterAwareTestUtils.createBasicHostInfo("new-writer-host", "test");
+    final HostInfo newWriterHost = createBasicHostInfo("new-writer-host");
     final List<HostInfo> newTopology = new ArrayList<>();
     newTopology.add(newWriterHost);
     newTopology.add(readerA_Host);
     newTopology.add(readerB_Host);
 
-    when(mockConnectionProvider.connect(refEq(writerHost))).thenThrow(SQLException.class);
-    when(mockConnectionProvider.connect(refEq(readerA_Host))).thenReturn(mockReaderA_Connection);
-    when(mockConnectionProvider.connect(refEq(readerB_Host))).thenReturn(mockReaderB_Connection);
-    when(mockConnectionProvider.connect(refEq(newWriterHost))).thenThrow(SQLException.class);
+    when(mockConnectionProvider.connect(writerHost)).thenThrow(SQLException.class);
+    when(mockConnectionProvider.connect(readerA_Host)).thenReturn(mockReaderA_Connection);
+    when(mockConnectionProvider.connect(readerB_Host)).thenReturn(mockReaderB_Connection);
+    when(mockConnectionProvider.connect(newWriterHost)).thenThrow(SQLException.class);
 
     when(mockTopologyService.getTopology(any(JdbcConnection.class), any(Boolean.class)))
         .thenReturn(newTopology);
 
     when(mockReaderFailover.getReaderConnection(ArgumentMatchers.anyList()))
-        .thenReturn(new ReaderFailoverResult(mockReaderA_Connection, 1, true));
+        .thenReturn(new ConnectionAttemptResult(mockReaderA_Connection, 1, true));
 
     final ClusterAwareWriterFailoverHandler target =
         new ClusterAwareWriterFailoverHandler(
             mockTopologyService,
             mockConnectionProvider,
             mockReaderFailover,
-            new HashMap<>(),
             5000,
             2000,
             2000,
             mockLog);
-    final WriterFailoverResult result = target.failover(currentTopology);
+    final ResolvedHostInfo result = target.failover(currentTopology);
 
     assertFalse(result.isConnected());
     assertFalse(result.isNewHost());
 
-    verify(mockTopologyService, times(1)).addToDownHostList(refEq(writerHost));
-    verify(mockTopologyService, atLeastOnce()).addToDownHostList(refEq(newWriterHost));
+    verify(mockTopologyService, times(1)).addToDownHostList(eq(writerHost));
+    verify(mockTopologyService, atLeastOnce()).addToDownHostList(eq(newWriterHost));
   }
 }
diff --git a/src/test/java/testsuite/failover/FailoverIntegrationTest.java b/src/test/java/testsuite/failover/FailoverIntegrationTest.java
index f78bc57..1db383f 100644
--- a/src/test/java/testsuite/failover/FailoverIntegrationTest.java
+++ b/src/test/java/testsuite/failover/FailoverIntegrationTest.java
@@ -37,7 +37,6 @@ import com.amazonaws.services.rds.model.DBClusterMember;
 import com.amazonaws.services.rds.model.DescribeDBClustersRequest;
 import com.amazonaws.services.rds.model.DescribeDBClustersResult;
 import com.amazonaws.services.rds.model.FailoverDBClusterRequest;
-import com.mysql.cj.conf.PropertyKey;
 import com.mysql.cj.log.Log;
 import com.mysql.cj.log.LogFactory;
 import org.apache.commons.dbcp2.BasicDataSource;
@@ -68,8 +67,8 @@ import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
 /** Integration testing with Aurora MySQL failover logic. */
-@Disabled
 @TestMethodOrder(MethodOrderer.Alphanumeric.class)
+@Disabled
 public class FailoverIntegrationTest {
   /*
    * Before running these tests we need to initialize the test cluster as the following.
@@ -115,7 +114,13 @@ public class FailoverIntegrationTest {
   private final AmazonRDS rdsClient = AmazonRDSClientBuilder.standard().build();
   private Connection testConnection;
 
-  private final Map<String, CrashInstanceRunnable> instanceCrasherMap = new HashMap<>();
+  private CrashInstanceRunnable instanceCrasher1;
+  private CrashInstanceRunnable instanceCrasher2;
+  private CrashInstanceRunnable instanceCrasher3;
+  private CrashInstanceRunnable instanceCrasher4;
+  private CrashInstanceRunnable instanceCrasher5;
+
+  private Map<String, CrashInstanceRunnable> instanceCrasherMap = new HashMap<>();
 
   /**
    * FailoverIntegrationTest constructor.
@@ -126,11 +131,11 @@ public class FailoverIntegrationTest {
 
     initiateInstanceNames();
 
-    CrashInstanceRunnable instanceCrasher1 = new CrashInstanceRunnable(INSTANCE_ID_1);
-    CrashInstanceRunnable instanceCrasher2 = new CrashInstanceRunnable(INSTANCE_ID_2);
-    CrashInstanceRunnable instanceCrasher3 = new CrashInstanceRunnable(INSTANCE_ID_3);
-    CrashInstanceRunnable instanceCrasher4 = new CrashInstanceRunnable(INSTANCE_ID_4);
-    CrashInstanceRunnable instanceCrasher5 = new CrashInstanceRunnable(INSTANCE_ID_5);
+    instanceCrasher1 = new CrashInstanceRunnable(INSTANCE_ID_1);
+    instanceCrasher2 = new CrashInstanceRunnable(INSTANCE_ID_2);
+    instanceCrasher3 = new CrashInstanceRunnable(INSTANCE_ID_3);
+    instanceCrasher4 = new CrashInstanceRunnable(INSTANCE_ID_4);
+    instanceCrasher5 = new CrashInstanceRunnable(INSTANCE_ID_5);
 
     instanceCrasherMap.put(INSTANCE_ID_1, instanceCrasher1);
     instanceCrasherMap.put(INSTANCE_ID_2, instanceCrasher2);
@@ -677,25 +682,25 @@ public class FailoverIntegrationTest {
 
   @Test
   public void test5_1_takeOverConnectionProperties() throws SQLException, InterruptedException {
-    final Properties props = new Properties();
-    props.setProperty(PropertyKey.USER.getKeyName(), TEST_USERNAME);
-    props.setProperty(PropertyKey.PASSWORD.getKeyName(), TEST_PASSWORD);
-    props.setProperty(PropertyKey.allowMultiQueries.getKeyName(), "false");
+    final String initalWriterId = getDBClusterWriterInstanceId();
+    assertEquals(INSTANCE_ID_1, initalWriterId);
 
-    // Establish the topology cache so that we can later assert that testConnection does not inherit properties from
-    // establishCacheConnection either before or after failover
-    final Connection establishCacheConnection = DriverManager.getConnection(getClusterEndpoint(), props);
-    establishCacheConnection.close();
+    final Properties props = new Properties();
+    props.setProperty("user", TEST_USERNAME);
+    props.setProperty("password", TEST_PASSWORD);
+    props.setProperty("allowMultiQueries", "true");
+    props.setProperty("gatherPerfMetrics", "true");
 
-    props.setProperty(PropertyKey.allowMultiQueries.getKeyName(), "true");
-    testConnection = DriverManager.getConnection(getClusterEndpoint(), props);
+    testConnection =
+        DriverManager.getConnection(
+            DB_CONN_STR_PREFIX + initalWriterId + DB_CONN_STR_SUFFIX, props);
 
     // Verify that connection accepts multi-statement sql
     final Statement myStmt = testConnection.createStatement();
     myStmt.executeQuery("select @@aurora_server_id; select 1; select 2;");
 
     // Crash Instance1 and nominate a new writer
-    failoverClusterAndWaitUntilWriterChanged(INSTANCE_ID_1);
+    failoverClusterAndWaitUntilWriterChanged(initalWriterId);
 
     assertFirstQueryThrows(testConnection, "08S02");
 
@@ -705,14 +710,10 @@ public class FailoverIntegrationTest {
   }
 
   /* Helper functions. */
-  private String getClusterEndpoint() {
-    String suffix = DB_CONN_STR_SUFFIX.startsWith(".") ? DB_CONN_STR_SUFFIX.substring(1) : DB_CONN_STR_SUFFIX;
-    return DB_CONN_STR_PREFIX + TEST_DB_CLUSTER_IDENTIFIER + ".cluster-" + suffix;
-  }
 
-  private DBCluster getDBCluster() {
+  private DBCluster getDBCluster(String dbClusterIdentifier) {
     DescribeDBClustersRequest dbClustersRequest =
-        new DescribeDBClustersRequest().withDBClusterIdentifier(FailoverIntegrationTest.TEST_DB_CLUSTER_IDENTIFIER);
+        new DescribeDBClustersRequest().withDBClusterIdentifier(dbClusterIdentifier);
     DescribeDBClustersResult dbClustersResult = rdsClient.describeDBClusters(dbClustersRequest);
     List<DBCluster> dbClusterList = dbClustersResult.getDBClusters();
     return dbClusterList.get(0);
@@ -731,7 +732,7 @@ public class FailoverIntegrationTest {
   }
 
   private List<DBClusterMember> getDBClusterMemberList() {
-    DBCluster dbCluster = getDBCluster();
+    DBCluster dbCluster = getDBCluster(TEST_DB_CLUSTER_IDENTIFIER);
     return dbCluster.getDBClusterMembers();
   }
 
@@ -839,10 +840,10 @@ public class FailoverIntegrationTest {
 
   private void waitUntilClusterHasRightState() throws InterruptedException {
     this.log.logDebug("Wait until cluster is in available state.");
-    String status = getDBCluster().getStatus();
+    String status = getDBCluster(TEST_DB_CLUSTER_IDENTIFIER).getStatus();
     while (!"available".equalsIgnoreCase(status)) {
       Thread.sleep(3000);
-      status = getDBCluster().getStatus();
+      status = getDBCluster(TEST_DB_CLUSTER_IDENTIFIER).getStatus();
     }
     this.log.logDebug("Cluster is available.");
   }
diff --git a/src/test/java/testsuite/regression/ConnectionRegressionTest.java b/src/test/java/testsuite/regression/ConnectionRegressionTest.java
index adae5f0..66afc74 100644
--- a/src/test/java/testsuite/regression/ConnectionRegressionTest.java
+++ b/src/test/java/testsuite/regression/ConnectionRegressionTest.java
@@ -57,7 +57,10 @@ import com.mysql.cj.util.LogUtils;
 import com.mysql.cj.util.StringUtils;
 import com.mysql.cj.util.TimeUtil;
 import com.mysql.cj.util.Util;
-import org.junit.jupiter.api.*;
+import org.junit.jupiter.api.Disabled;
+import org.junit.jupiter.api.MethodOrderer;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.TestMethodOrder;
 import testsuite.BaseQueryInterceptor;
 import testsuite.BaseTestCase;
 import testsuite.BufferingLogger;
@@ -123,7 +126,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for BUG#3554 - Not specifying database in URL causes MalformedURL exception.
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -196,7 +199,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
     /**
      * Tests if the driver configures character sets correctly for 4.1.x servers. Requires that the 'admin connection' is configured, as this test needs to
      * create/drop databases.
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -260,7 +263,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests setReadOnly() being reset during failover
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -352,7 +355,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for BUG#4334, port #'s not being picked up for failover/autoreconnect.
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -505,7 +508,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for BUG#6966, connections starting up failed-over (due to down source) never retry source.
-     *
+     * 
      * @throws Exception
      *             Note, test is timing-dependent, but should work in most cases.
      */
@@ -560,7 +563,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Test fix for BUG#7952 -- Infinite recursion when 'falling back' to source in failover configuration.
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -614,14 +617,14 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
             /*
              * long begin = System.currentTimeMillis();
-             *
+             * 
              * failoverConnection.setAutoCommit(true);
-             *
+             * 
              * long end = System.currentTimeMillis();
-             *
+             * 
              * assertTrue("Probably didn't try failing back to the
              * source....check test", (end - begin) > 500);
-             *
+             * 
              * failoverConnection.createStatement().executeQuery("SELECT 1");
              */
         } finally {
@@ -633,7 +636,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for BUG#7607 - MS932, SHIFT_JIS and Windows_31J not recog. as aliases for sjis.
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -749,7 +752,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for BUG#9206, can not use 'UTF-8' for characterSetResults configuration property.
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -761,7 +764,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * These two charsets have different names depending on version of MySQL server.
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -777,7 +780,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for BUG#10144 - Memory leak in ServerPreparedStatement if serverPrepare() fails.
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -802,7 +805,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for BUG#10496 - SQLException is thrown when using property "characterSetResults"
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -820,7 +823,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for BUG#11259, autoReconnect ping causes exception on connection startup.
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -839,7 +842,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for BUG#11879 -- ReplicationConnection won't switch to replica, throws "Catalog can't be null" exception.
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -861,7 +864,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for BUG#11976 - maxPerformance.properties mis-spells "elideSetAutoCommits".
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -875,7 +878,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for BUG#12218, properties shared between source and replica with replication connection.
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -906,7 +909,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for BUG#12229 - explainSlowQueries hangs with server-side prepared statements.
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -938,7 +941,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for BUG#12752 - Cp1251 incorrectly mapped to win1251 for servers newer than 4.0.x.
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -950,7 +953,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for BUG#12753, sessionVariables=....=...., doesn't work as it's tokenized incorrectly.
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -975,7 +978,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for BUG#13048 - maxQuerySizeToLog is not respected.
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -1032,7 +1035,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for BUG#13453 - can't use & or = in URL configuration values (we now allow you to use www-form-encoding).
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -1069,7 +1072,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for BUG#15065 - Usage advisor complains about unreferenced columns, even though they've been referenced.
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -1172,7 +1175,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for BUG#15544, no "dos" character set in MySQL > 4.1.0
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -1220,9 +1223,9 @@ public class ConnectionRegressionTest extends BaseTestCase {
     /**
      * Tests fix for BUG#15570 - ReplicationConnection incorrectly copies state, doesn't transfer connection context correctly when transitioning between the
      * same read-only states.
-     *
+     * 
      * (note, this test will fail if the test user doesn't have permission to "USE 'mysql'".
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -1284,7 +1287,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests bug where downed replica caused round robin load balance not to cycle back to first host in the list.
-     *
+     * 
      * @throws Exception
      *             Note, test is timing-dependent, but should work in most cases.
      */
@@ -1332,7 +1335,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests to insure proper behavior for BUG#24706.
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -1386,7 +1389,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for BUG#25514 - Timer instance used for Statement.setQueryTimeout() created per-connection, rather than per-VM, causing memory leak.
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -1439,7 +1442,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
     /**
      * Ensures that we don't miss getters/setters for driver properties defined in PropertyDefinitions so that names given in documentation work with
      * DataSources which will use JavaBean-style names and reflection to set the values (and often fail silently! when the method isn't available).
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -1539,9 +1542,9 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for BUG#25545 - Client flags not sent correctly during handshake when using SSL.
-     *
+     * 
      * Requires test certificates from testsuite/ssl-test-certs to be installed on the server being tested.
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -1573,9 +1576,9 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for BUG#36948 - Trying to use trustCertificateKeyStoreUrl causes an IllegalStateException.
-     *
+     * 
      * Requires test certificates from testsuite/ssl-test-certs to be installed on the server being tested.
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -1607,7 +1610,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for BUG#27655 - getTransactionIsolation() uses "SHOW VARIABLES LIKE" which is very inefficient on MySQL-5.0+
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -1636,7 +1639,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
     /**
      * Tests fix for issue where a failed-over connection would let a application call setReadOnly(false), when that call should be ignored until the connection
      * is reconnected to a writable Source.
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -1734,7 +1737,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
      * Test of a new feature to fix BUG 22643, specifying a "validation query" in your connection pool that starts with "slash-star ping slash-star" _exactly_
      * will cause the driver to " + instead send a ping to the server (much lighter weight), and when using a ReplicationConnection or a LoadBalancedConnection,
      * will send the ping across all active connections.
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -1828,7 +1831,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
     /**
      * Tests fix for BUG#33734 - NullPointerException when using client-side prepared statements and enabling caching of prepared statements
      * (only present in nightly builds of 5.1).
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -1843,7 +1846,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * 34703 [NEW]: isValild() aborts Connection on timeout
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -2372,7 +2375,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for BUG#44587, provide last packet sent/received timing in all connection failure errors.
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -2400,7 +2403,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for BUG#45419, ensure that time is not converted to seconds before being reported as milliseconds.
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -2648,7 +2651,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for Bug#51643 - connection chosen by load balancer "sticks" to statements that live past commit()/rollback().
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -3846,10 +3849,10 @@ public class ConnectionRegressionTest extends BaseTestCase {
      * sha256_password_public_key_path, caching_sha2_password_private_key_path and caching_sha2_password_public_key_path config options are unset).
      * 2) additional server instance pointed by com.mysql.cj.testsuite.url.openssl variable configured with default-authentication-plugin=sha256_password and
      * RSA encryption enabled.
-     *
+     * 
      * To run this test please add this variable to ant call:
      * -Dcom.mysql.cj.testsuite.url.openssl=jdbc:mysql://localhost:3307/test?user=root&password=pwd
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -4562,7 +4565,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for BUG#57662, Incorrect Query Duration When useNanosForElapsedTime Enabled
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -4646,7 +4649,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for BUG#11237 useCompression=true and LOAD DATA LOCAL INFILE SQL Command
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -4664,7 +4667,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
         File testFile = File.createTempFile("cj-testloaddata", ".dat");
         testFile.deleteOnExit();
 
-        // TODO: following cleanup doesn't work correctly during concurrent execution of testsuite
+        // TODO: following cleanup doesn't work correctly during concurrent execution of testsuite 
         // cleanupTempFiles(testFile, "cj-testloaddata");
 
         BufferedOutputStream bOut = new BufferedOutputStream(new FileOutputStream(testFile));
@@ -4975,7 +4978,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for BUG#16224249 - Deadlock on concurrently used LoadBalancedMySQLConnection
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -5090,7 +5093,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for BUG#68763, ReplicationConnection.isSourceConnection() returns false always
-     *
+     * 
      * @throws Exception
      *             if the test fails.
      */
@@ -5107,7 +5110,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for BUG#68733, ReplicationConnection does not ping all underlying active physical connections to replicas.
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -5341,7 +5344,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for BUG#68400 useCompression=true and connect to server, zip native method cause out of memory
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -5501,7 +5504,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for BUG#17251955, ARRAYINDEXOUTOFBOUNDSEXCEPTION ON LONG MULTI-BYTE DB/USER NAMES
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -5552,7 +5555,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for BUG#69506 - XAER_DUPID error code is not returned when a duplicate XID is offered in Java.
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -5579,7 +5582,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
     /**
      * Tests fix for BUG#69746, ResultSet closed after Statement.close() when dontTrackOpenResources=true
      * active physical connections to replicas.
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -5697,10 +5700,10 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * This test requires additional server instance configured withm default-authentication-plugin=sha256_password and RSA encryption enabled.
-     *
+     * 
      * To run this test please add this variable to ant call:
      * -Dcom.mysql.cj.testsuite.url.openssl=jdbc:mysql://localhost:3307/test?user=root&password=pwd
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -5784,7 +5787,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for Bug#69452 - Memory size connection property doesn't support large values well
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -5825,7 +5828,7 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for Bug#69777 - Setting maxAllowedPacket below 8203 makes blobSendChunkSize negative.
-     *
+     * 
      * @throws Exception
      */
     @Test
@@ -5864,10 +5867,9 @@ public class ConnectionRegressionTest extends BaseTestCase {
 
     /**
      * Tests fix for BUG#69579 - DriverManager.setLoginTimeout not honored.
-     *
+     * 
      * @throws Exception
      */
-    @Disabled
     @Test
     public void testBug69579() throws Exception {
         // Mock Server that accepts network connections and does nothing with them, for connection timeout testing.
@@ -5924,9 +5926,10 @@ public class ConnectionRegressionTest extends BaseTestCase {
         final String testURL = "jdbc:mysql://localhost:" + serverPort;
         Connection testConn = null;
         final int oldLoginTimeout = DriverManager.getLoginTimeout();
-        final int loginTimeout = 6;
+        final int loginTimeout = 3;
         final int testTimeout = loginTimeout * 2;
         long timestamp = System.currentTimeMillis();
+
         try {
             DriverManager.setLoginTimeout(loginTimeout);
 
